<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><link rel="shortcut icon" href="/martinjkellogg.com/teaching/cs485-sp25/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/martinjkellogg.com/teaching/cs485-sp25/assets/css/just-the-docs-default.css"> <script src="/martinjkellogg.com/teaching/cs485-sp25/assets/js/vendor/lunr.min.js"></script> <script src="/martinjkellogg.com/teaching/cs485-sp25/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>PA2: Semantic Analyzer | CS 485 Compilers (Sp25)</title><meta name="generator" content="Jekyll v3.9.2" /><meta property="og:title" content="PA2: Semantic Analyzer" /><meta name="author" content="Martin Kellogg" /><meta property="og:locale" content="en_US" /><meta name="description" content="The course website for NJIT CS 485 in Spring 2025, as taught by Martin Kellogg" /><meta property="og:description" content="The course website for NJIT CS 485 in Spring 2025, as taught by Martin Kellogg" /><link rel="canonical" href="https://kelloggm.github.io/martinjkellogg.com/teaching/cs485-sp25/projects/pa2.html" /><meta property="og:url" content="https://kelloggm.github.io/martinjkellogg.com/teaching/cs485-sp25/projects/pa2.html" /><meta property="og:site_name" content="CS 485 Compilers (Sp25)" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="PA2: Semantic Analyzer" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Martin Kellogg"},"description":"The course website for NJIT CS 485 in Spring 2025, as taught by Martin Kellogg","headline":"PA2: Semantic Analyzer","url":"https://kelloggm.github.io/martinjkellogg.com/teaching/cs485-sp25/projects/pa2.html"}</script><body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"><title>Search</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"><title>Document</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><title id="svg-external-link-title">(external link)</title><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> </svg><div class="side-bar"><div class="site-header"> <a href="/martinjkellogg.com/teaching/cs485-sp25/" class="site-title lh-tight"> CS 485 Compilers (Sp25) </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Programming Assignments category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/" class="nav-list-link">Programming Assignments</a><ul class="nav-list "><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/pa1.html" class="nav-list-link">PA1: Rosetta Stone</a><li class="nav-list-item active"><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/pa2.html" class="nav-list-link active">PA2: Semantic Analyzer</a></ul><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Tutorials category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/martinjkellogg.com/teaching/cs485-sp25/tutorials/" class="nav-list-link">Tutorials</a><ul class="nav-list "><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/tutorials/reading-papers.html" class="nav-list-link">How to Read a Paper (Useful for "Optional" Readings)</a><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html" class="nav-list-link">Ubuntu Setup Guide</a></ul><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/calendar/" class="nav-list-link">Calendar</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/exam/" class="nav-list-link">Exams</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/staff/" class="nav-list-link">Staff</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/languages/" class="nav-list-link">Supported Languages</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/about/" class="nav-list-link">Syllabus</a></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div class="search"><div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search CS 485 Compilers (Sp25)" aria-label="Search CS 485 Compilers (Sp25)" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label></div><div id="search-results" class="search-results"></div></div><nav aria-label="Auxiliary" class="aux-nav"><ul class="aux-nav-list"><li class="aux-nav-list-item"> <a href="" class="site-button" > Canvas </a><li class="aux-nav-list-item"> <a href="" class="site-button" > Discord </a><li class="aux-nav-list-item"> <a href="" class="site-button" > Gradescope </a></ul></nav></div><div id="main-content-wrap" class="main-content-wrap"><nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/">Programming Assignments</a><li class="breadcrumb-nav-list-item"><span>PA2: Semantic Analyzer</span></ol></nav><div id="main-content" class="main-content" role="main"><h2 class="fs-6" id="pa2-semantic-analyzer"> <a href="#pa2-semantic-analyzer" class="anchor-heading" aria-labelledby="pa2-semantic-analyzer"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PA2: Semantic Analyzer <strong class="label label-red">Due Monday, 3 March 2025, 11:59PM AoE.</strong></h2><p>You may complete this assignment in any language listed on the <a href="../languages/">languages page</a> in buckets 1, 2, or 3.</p><p>You may work in a team of two people for this assignment. You may work in a team for any or all subsequent programming assignments. You do not need to keep the same teammate between this assignment and subsequent assignments. The course staff are not responsible for finding you a willing teammate. You are permitted to work alone, if you choose.</p><h3 id="goal"> <a href="#goal" class="anchor-heading" aria-labelledby="goal"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Goal</h3><p>For this assignment you will write a <em>semantic analyzer</em>. Among other things, this involves traversing the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> and the class hierarchy. You will reject all Cool programs that do not comply with the Cool type system.</p><p>You will also write additional code to unserialize the AST produced by the provided parser and to serialize the class map, implementation map, parent map, and annotated AST produced by your semantic analysis.</p><h3 id="specification"> <a href="#specification" class="anchor-heading" aria-labelledby="specification"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Specification</h3><p>You must create three artifacts:</p><ol><li>A program that takes a single command-line argument (e.g., <code class="language-plaintext highlighter-rouge">file.cl-ast</code>). That argument will be an ASCII text Cool abstract syntax tree file (as described below in the section “The .cl-ast File Format”). Your program must either indicate that there is an error in the input (e.g., a type error) or emit <code class="language-plaintext highlighter-rouge">file.cl-type</code>, a serialized Cool abstract syntax tree, class map, implementation map, and parent map. If your program is called <code class="language-plaintext highlighter-rouge">checker</code>, invoking <code class="language-plaintext highlighter-rouge">checker file.cl-ast</code> should yield the same output as <code class="language-plaintext highlighter-rouge">cool --type file.cl</code>. Your program will consist of a number of files in the language of your choice. The main entry point for your program must be in a file called <code class="language-plaintext highlighter-rouge">main.$EXT</code>, where <code class="language-plaintext highlighter-rouge">$EXT</code> is replaced by the customary file extension used by your programming language of choice (e.g., <code class="language-plaintext highlighter-rouge">main.ml</code> for OCaml, or <code class="language-plaintext highlighter-rouge">main.c</code> for C). If you are using a language that typically capitalizes file names (like Java), you should follow that convention as you normally would (so, a Java implementation’s entrypoint should be in <code class="language-plaintext highlighter-rouge">Main.java</code>). Your program cannot rely on non-standard external dependencies, and must build using your language’s standard compiler command. See the <a href="../languages/">language page</a>’s entry for your language for more details.<li>A plain ASCII text file called <code class="language-plaintext highlighter-rouge">readme.txt</code> describing your design decisions and choice of test cases. See the grading rubric. A few paragraphs should suffice.<li>Testcases <code class="language-plaintext highlighter-rouge">good.cl</code>, <code class="language-plaintext highlighter-rouge">bad1.cl</code>, <code class="language-plaintext highlighter-rouge">bad2.cl</code> and <code class="language-plaintext highlighter-rouge">bad3.cl</code>. The first should pass the semantic analysis stage. The remaining three should yield semantic analysis errors.</ol><h3 id="the-cl-ast-file-format"> <a href="#the-cl-ast-file-format" class="anchor-heading" aria-labelledby="the-cl-ast-file-format"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The .cl-ast File Format</h3><p>The input to your program will be in the <code class="language-plaintext highlighter-rouge">.cl-ast</code> format described in this section. The <code class="language-plaintext highlighter-rouge">cool</code> reference compiler produces <code class="language-plaintext highlighter-rouge">.cl-ast</code> files from <code class="language-plaintext highlighter-rouge">.cl</code> files; you should use it to do so when testing. You may assume that your program only receives well-formed <code class="language-plaintext highlighter-rouge">.cl-ast</code> files. If you want to see examples of the format, use the <code class="language-plaintext highlighter-rouge">--parse</code> flag of reference compiler to generate <code class="language-plaintext highlighter-rouge">.cl-ast</code> files.</p><p>If you are having trouble reading in <code class="language-plaintext highlighter-rouge">.cl-ast</code> files, you are almost certainly doing something wrong: the format is designed to be easy to parse (it may require a bit of work to cover all cases, but the code you write should be pretty formulaic). Check with the TAs if you’re finding it difficult for any reason—the usual case is a misunderstanding of the specification, which is easy to clear up by explaining the trouble to the TA.</p><p>The general format of a <code class="language-plaintext highlighter-rouge">.cl-ast</code> file follows the Cool Reference Manual Syntax chart. Basically, we do a <a href="http://en.wikipedia.org/wiki/Tree_traversal">pre-order traversal</a> of the abstract syntax tree, writing down every node as we come to it.</p><p>We now describe exactly what the parser outputs for each kind of node. You can view this as specifying a set of mutually-recursive tree-walking functions. The notation “superclass:<em>identifier</em>” means “output the superclass using the rule (below) for outputting an <em>identifier</em>”. The notation “\n” means “output a newline”.</p><ul><li><strong>To Output An AST</strong>. A Cool AST is a list of classes. Output the list of classes.<li><strong>To Output A List (of classes, or features, or whatever).</strong> Output the number of elements, then a newline, then output each list element in turn.<li><strong>To Output A Class.</strong> Output the class name as an identifier. Then output either:<ul><li><code class="language-plaintext highlighter-rouge">no_inherits</code> \n<li><code class="language-plaintext highlighter-rouge">inherits</code> \n superclass:<em>identifier</em> <br />Then output the list of features.</ul><li><strong>To Output An Identifier.</strong> Output the source-file line number, then a newline, then the identifier string, then a newline.<li><strong>To Output A Feature.</strong> Output the name of the feature and then a newline and then any subparts, as given below:<ul><li><code class="language-plaintext highlighter-rouge">attribute_no_init</code> \n name:<em>identifier</em> type:<em>identifier</em><li><code class="language-plaintext highlighter-rouge">attribute_init</code> \n name:<em>identifier</em> type:<em>identifier</em> init:<em>exp</em><li><code class="language-plaintext highlighter-rouge">method</code> \n name:<em>identifier</em> <em>formals-list</em> \n type:<em>identifier</em> body:<em>exp</em></ul><li><strong>To Output A Formal.</strong> Output the name as an identifier on line and then the type as an identifier on a line.<li><strong>To Output An Expression.</strong> Output the line number of the expression and then a newline. Output the name of the expression and then a newline and then any subparts, as given below:<ul><li><code class="language-plaintext highlighter-rouge">assign</code> \n var:<em>identifier</em> rhs:<em>exp</em><li><code class="language-plaintext highlighter-rouge">dynamic_dispatch</code> \n e:<em>exp</em> method:<em>identifier</em> args:<em>exp-list</em><li><code class="language-plaintext highlighter-rouge">static_dispatch</code> \n e:<em>exp</em> type:<em>identifier</em> method:<em>identifier</em> args:<em>exp-list</em><li><code class="language-plaintext highlighter-rouge">self_dispatch</code> \n method:<em>identifier</em> args:<em>exp-list</em><li><code class="language-plaintext highlighter-rouge">if</code> \n predicate:<em>exp</em> then:<em>exp</em> else:<em>exp</em><li><code class="language-plaintext highlighter-rouge">while</code> \n predicate:<em>exp</em> body:<em>exp</em><li><code class="language-plaintext highlighter-rouge">block</code> \n body:<em>exp</em>-list<li><code class="language-plaintext highlighter-rouge">new</code> \n class:<em>identifier</em><li><code class="language-plaintext highlighter-rouge">isvoid</code> \n e:<em>exp</em><li><code class="language-plaintext highlighter-rouge">plus</code> \n x:<em>exp</em> y:<em>exp</em><li><code class="language-plaintext highlighter-rouge">minus</code> \n x:<em>exp</em> y:<em>exp</em><li><code class="language-plaintext highlighter-rouge">times</code> \n x:<em>exp</em> y:<em>exp</em><li><code class="language-plaintext highlighter-rouge">divide</code> \n x:<em>exp</em> y:<em>exp</em><li><code class="language-plaintext highlighter-rouge">lt</code> \n x:<em>exp</em> y:<em>exp</em><li><code class="language-plaintext highlighter-rouge">le</code> \n x:<em>exp</em> y:<em>exp</em><li><code class="language-plaintext highlighter-rouge">eq</code> \n x:<em>exp</em> y:<em>exp</em><li><code class="language-plaintext highlighter-rouge">not</code> \n x:<em>exp</em><li><code class="language-plaintext highlighter-rouge">negate</code> \n x:<em>exp</em><li><code class="language-plaintext highlighter-rouge">integer</code> \n <code class="language-plaintext highlighter-rouge">the_integer_constant</code> \n<li><code class="language-plaintext highlighter-rouge">string</code> \n <code class="language-plaintext highlighter-rouge">the_string_constant</code> \n<li><code class="language-plaintext highlighter-rouge">_identifier_</code> \n variable:<em>identifier</em> &lt;p style="color:red;"&gt;(note that this is not the same as the integer and string cases above)&lt;/p&gt;<li><code class="language-plaintext highlighter-rouge">true</code> \n<li><code class="language-plaintext highlighter-rouge">false</code> \n</ul><li><strong>To Output A let Expression.</strong> (Output the line number, as usual.) Output <code class="language-plaintext highlighter-rouge">let</code> \n. Then output the binding list. To output a binding, do either:<ul><li><code class="language-plaintext highlighter-rouge">let_binding_no_init</code> \n variable:<em>identifier</em> type:<em>identifier</em><li><code class="language-plaintext highlighter-rouge">let_binding_init</code> \n variable:<em>identifier</em> type:<em>identifier</em> value:<em>exp</em> <br />Finally, output the expression that is the body of the let.</ul><li><strong>To Output A case Expression.</strong> (Output the line number, as usual.) Output <code class="language-plaintext highlighter-rouge">case</code> \n. Then output the case expression. Then output the case-elements list. To output a case-element, output the variable as an <em>identifier</em>, then the type as an <em>identifier</em>, then the case-element-body as an <em>exp</em>.</ul><p>Example input <code class="language-plaintext highlighter-rouge">.cl</code> file:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* Line 01 *)
(* Line 02 *)
(* Line 03 *)  class List {
(* Line 04 *)     -- Define operations on lists.
(* Line 05 *)
(* Line 06 *)     cons(i : Int) : List {
(* Line 07 *)        (new Cons).init(i, self)
(* Line 08 *)     };
(* Line 09 *)
(* Line 10 *)  };
</code></pre></div></div><p>Corresponding <code class="language-plaintext highlighter-rouge">.cl-ast</code> file, <em>with comments</em> (will not be present in the output of the reference compiler):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fier
6                      --   line number of return type identifier
List                   --   return type identifier
7                      --    line number of body expression
dynamic_dispatch       --    kind of body expression
7                      --     line number of dispatch receiver expression
new                    --     kind of dispatch receiver expression
7                      --      line number of new-class identifier
Cons                   --      new-class identifier
7                      --     line number of dispatch method identifier
init                   --     dispatch method identifier
2                      --     number of arguments in dispatch
7                      --      line number of first argument expression
identifier             --      kind of first argument expression
7                      --       line number of the identifier
i                      --       what is the identifier?
7                      --      line number of second argument expression
identifier             --      kind of second argument expression
7                      --       line number of the identifier
self                   --       what is the identifier?
</code></pre></div></div><h3 id="error-reporting"> <a href="#error-reporting" class="anchor-heading" aria-labelledby="error-reporting"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Error Reporting</h3><p>To report an error, write the string:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR: $line_number: Type-Check: $message
</code></pre></div></div><p>to standard output and terminate the program. You may write whatever you want in the message, but it should be fairly indicative. Example erroneous input:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Main inherits IO {
 main() : Object {
   out_string("Hello, world.\n" + 16777216) -- adding string + int !?
 } ;
} ;
</code></pre></div></div><p>Example error report output:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR: 3: Type-Check: arithmetic on String Int instead of Ints
</code></pre></div></div><h4 id="line-number-error-reporting"> <a href="#line-number-error-reporting" class="anchor-heading" aria-labelledby="line-number-error-reporting"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Line Number Error Reporting</h4><p>The typing rules do not directly specify the line numbers on which errors are to be reported. The Cool reference compiler uses these guidelines (possibly surprising ones are <em>italicized</em>), which you should also follow:</p><ul><li>Errors related to parameter-less method <code class="language-plaintext highlighter-rouge">main</code> in class <code class="language-plaintext highlighter-rouge">Main</code>: always line 0<li>Inheritance cycle: always line 0<li>Other inheritance type problem: inherited type identifier location<li>self or <code class="language-plaintext highlighter-rouge">SELF_TYPE</code> used in wrong place: self (resp. <code class="language-plaintext highlighter-rouge">SELF_TYPE</code>) identifier (resp. type) location<li>Redefining a feature: (second) feature location<li>Redefining a formal or class: (second) identifier location<li>Other attribute problems: attribute location<li>Redefining a method and changing types: (second) type location<li>Other problems with redefining a method: method location<li>Method body type does not conform: method <em>name identifier</em> location<li>Attribute initializer does not conform: attribute <em>name identifier</em> location<li>Errors with types of arguments to relational/arithmetic operations: location of relational/arithmetic operation expression<li>Errors with types of <code class="language-plaintext highlighter-rouge">while</code> / <code class="language-plaintext highlighter-rouge">if</code> subexpression(s): location of (enclosing) <code class="language-plaintext highlighter-rouge">while</code> or <code class="language-plaintext highlighter-rouge">if</code> expression (<em>not</em> the location of the conditional expression)<li>Errors with case expression (e.g., lub): location of <code class="language-plaintext highlighter-rouge">case</code> expression<li>Errors with conformance in <code class="language-plaintext highlighter-rouge">let</code>: location of <code class="language-plaintext highlighter-rouge">let</code> expression (<em>not</em> location of initializer)<li>Errors in blocks: location of (beginning of) block expression<li>Errors in actual arguments: location of method invocation expression (<em>not</em> the location of any particular actual argument)<li>Assignment does not conform: assignment expression location (<em>not</em> right-hand-side location)<li>Unknown identifier: location of identifier<li>Unknown method: location of method name identifier<li>Unknown type: location of type</ul><p>Remember that you do not have to match the English prose of the reference compiler’s error messages at all. You just have to get the line number right.</p><p>Semantic checks are <em>unordered</em> — if a program contains two or more errors, you may indicate whichever you like. (All of our test cases for grading will contain at most one error so this will not be an issue.)</p><h3 id="the-cl-type-file-format"> <a href="#the-cl-type-file-format" class="anchor-heading" aria-labelledby="the-cl-type-file-format"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The .cl-type File Format</h3><p>If there are no errors in <code class="language-plaintext highlighter-rouge">file.cl-ast</code> your program should create <code class="language-plaintext highlighter-rouge">file.cl-type</code> and serialize the class map, implementation map, parent map, and annotated AST to it.</p><p>The class and implementation maps are described in the Cool Reference Manual.</p><p>A <code class="language-plaintext highlighter-rouge">.cl-type</code> file consists of four sections:</p><ol><li>The class map.<li>The implementation map.<li>The parent map.<li>The annotated AST.</ol><p>Simply output the four sections in order, one after the other.</p><p>We will now describe exactly what to output for the class and implementation maps. The general idea and notation (one string per line, recursive descent) are the same as in the <code class="language-plaintext highlighter-rouge">.cl-ast</code> file format, described above.</p><p><strong>The Class Map</strong></p><ul><li>Output <code class="language-plaintext highlighter-rouge">class_map</code>\n.<li>Output the number of classes and then \n.<li>Output each class in turn (in ascending alphabetical order):<ul><li>Output the name of the class and then \n.<li>Output the number of attributes and then \n.<li>Output each attribute in turn (in order of appearance, with inherited attributes from a superclass coming first):<ul><li>Output <code class="language-plaintext highlighter-rouge">no_initializer</code> \n and then the attribute name \n and then the type name \n.<li><em>or</em> Output <code class="language-plaintext highlighter-rouge">initializer</code> \n and then the attribute name \n and then the type name \n and then the initializer expression.</ul></ul></ul><p><strong>The Implementation Map</strong></p><ul><li>Output <code class="language-plaintext highlighter-rouge">implementation_map</code>\n.<li>Output the number of classes and then \n.<li>Output each class in turn (in ascending alphabetical order):<ul><li>Output the name of the class and then \n.<li>Output the number of methods for that class and then \n.<li>Output each method in turn (in order of appearance, with inherited or overridden methods from a superclass coming first; internal methods are defined to appear in ascending alphabetical order):<ul><li>Output the method name and then \n.<li>Output the number of formals and then \n.<li>Output each formal’s name only:<ul><li>Output the name and then \n</ul><li>If this method is inherited from a parent class and not overriden, output the name of the ultimate parent class that defined the method body expression and then \n. Otherwise, output the name of the current class and then \n.<li>Output the method body expression.</ul></ul></ul><p><strong>The Parent Map</strong></p><ul><li>Output <code class="language-plaintext highlighter-rouge">parent_map</code>\n<li>Output the number of parent-child inheritance relations and then \n. This number is equal to the number of classes minus one (since <code class="language-plaintext highlighter-rouge">Object</code> has no parent).<li>Output each child class in turn (in ascending alphabetical order):<ul><li>Output the name of the child class and then \n.<li>Output the name of the child class’s parent and then \n.</ul></ul><p><strong>The Annotated AST</strong></p><ul><li>With two exceptions, the annotated AST format is identical to the normal AST format described above for the <code class="language-plaintext highlighter-rouge">.cl-ast</code> file.<li>The first change involves expressions. To output an <strong>Expression</strong>:<ol><li>Output the line number of the expression and then a newline (as in the <code class="language-plaintext highlighter-rouge">.cl-ast</code> format).<li><strong>Output the name of type associated with the expression and then a newline.</strong> For example, the expression 3+x is associated with the type Int. This is not required for any of the checkpoints for PA2, only in the final version of PA2.<li>Output the name of the expression and then a newline and then any subparts (as in the <code class="language-plaintext highlighter-rouge">.cl-ast</code> format).</ol><li>The second change is a new kind of expression, <em>internal</em>, used to represent the bodies of predefined methods. Internal expressions are those that are handled by the run-time system — you might think of them as part of the standard library. You output <strong>Internal Expressions</strong> (including the type annotation, as above) as follows:<ul><li>0 \n <em>type</em> \n <code class="language-plaintext highlighter-rouge">internal</code> \n Class.method \n <br />The valid kinds of internal expressions (i.e., the values for Class.method) are:<ul><li>IO.in_int IO.in_string IO.out_int IO.out_string Object.abort Object.copy Object.type_name String.concat String.length String.substr <br />They are formally defined in the Cool Reference Manual.</ul></ul></ul><p><em>Note that you must output information about all classes and methods defined in the program as well as all base classes (and their methods). Do not just print out “classes actually used” or “methods actually called” or something like that. Output all classes and methods — no optimizations or shortcuts!</em></p><h3 id="detailed-cl-type-example"> <a href="#detailed-cl-type-example" class="anchor-heading" aria-labelledby="detailed-cl-type-example"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Detailed .cl-type Example</h3><p>Now that we’ve formally defined the output specification, we can present a worked example. Here’s the example input we will consider:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Main inherits IO {
  my_attribute : Int &lt;- 5 ;
  main() : Object {
    out_string("Hello, world.\n")
  } ;
} ;
</code></pre></div></div><p>Resulting <code class="language-plaintext highlighter-rouge">.cl-type</code> class map output <em>with comments</em> (each row represents one line of the <code class="language-plaintext highlighter-rouge">.cl-type</code> output; you only need to emit the left-most column):</p><div class="table-wrapper"><table><thead><tr><th>.cl-type class map<th>comment<tbody><tr><td>class_map<td> <tr><td>6<td>number of classes<tr><td>Bool<td>note: includes predefined classes<tr><td>0<td> <tr><td>IO<td> <tr><td>0<td> <tr><td>Int<td> <tr><td>0<td> <tr><td>Main<td> <tr><td>1<td>Our Main has one attribute…<tr><td>initialzier<td> <tr><td>my_attribute<td>…named “my_attribute”…<tr><td>Int<td>…with type Int<tr><td>2<td>initializer expression line number<tr><td>Int<td>initializer expression type (see above: this is an expression <em>annotated</em> with a type) – do <strong>not</strong> emit these <em>expression</em> types for PA2c2!<tr><td>integer<td>initializer expression kind<tr><td>5<td>which integer constant is it?<tr><td>Object<td> <tr><td>0<td> <tr><td>String<td> <tr><td>0<td> </table></div><p>Resulting <code class="language-plaintext highlighter-rouge">.cl-type</code> implementation map <em>with comments</em>:</p><div class="table-wrapper"><table><thead><tr><th>.cl-type implementation map<th>comment<tbody><tr><td>implementation_map<td> <tr><td>6<td>six classes<tr><td>Bool<td>first is Bool<tr><td>3<td>- Bool has 3 methods<tr><td>abort<td>- first method in Bool is abort()<tr><td>0<td>– abort() has zero formal parameters<tr><td>Object<td>– name of parent class from which Bool inherits abort()<tr><td>0<td>– abort’s body expression starts on line 0<tr><td>Object<td>– abort’s body expression has type Object<tr><td>internal<td>– abort’s body is an internal kind of expression (i.e., a system call; see above)<tr><td>Object.abort<td>– extra detail on abort’s body expression<tr><td>copy<td>- second of Bool’s three methods is copy()<tr><td>0<td>– copy has 0 formal arguments<tr><td>Object<td>– name of parent class from which Bool inherits copy()<tr><td>0<td>– copy’s body expression starts on line 0<tr><td>SELF_TYPE<td>– copy’s body expression has type SELF_TYPE<tr><td>internal<td>– copy’s body is an internal kind of expression (i.e., a system call; see above)<tr><td>Object.copy<td>– extra detail on copy’s body expression<tr><td>… many lines skipped …<td> <tr><td>Main<td>another class is Main<tr><td>8<td>Main has 8 methods<tr><td>… many lines skipped …<td> <tr><td>main<td>- one of Main’s methods is main()<tr><td>0<td>– main has 0 formal arguments<tr><td>Main<td>– the name of the class where Main.main() is defined<tr><td>4<td>– the body expression of Main.main starts on line 4<tr><td>SELF_TYPE<td>– the body expression of Main.main has type SELF_TYPE<tr><td>self_dispatch<td>– the body of Main.main() is a self_dispatch kind of expression<tr><td>… many lines skipped …<td> </table></div><p>Finally, the resulting <code class="language-plaintext highlighter-rouge">.cl-type</code> parent map output <em>with comments</em>:</p><div class="table-wrapper"><table><tbody><tr><td>.cl-type parent map<td>comment<tr><td>parent_map<td> <tr><td>5<td>there are five clases with parents (Object is the sixth class)<tr><td>Bool<td>Bool’s parent…<tr><td>Object<td>…is Object<tr><td>IO<td>IO’s parent…<tr><td>Object<td>…is also Object<tr><td>Int<td> <tr><td>Object<td> <tr><td>Main<td>Main’s parent…<tr><td>IO<td>…is IO, rather than Object, because of the “inherits IO” on line 1<tr><td>String<td> <tr><td>Object<td> </table></div><p>Writing the rote code to output a <code class="language-plaintext highlighter-rouge">.cl-type</code> text file given an AST may take a bit of time but it should not be difficult; our reference implementation does it in 35 lines and cleaves closely to the structure given above. Reading in the AST is similarly straightforward; our reference implementation does it in 171 lines.</p><h3 id="commentary"> <a href="#commentary" class="anchor-heading" aria-labelledby="commentary"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Commentary</h3><p>You can do basic testing as follows:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cool --parse file.cl
$ cool --out reference --type file.cl
$ my-checker file.cl-ast
$ diff -b -B -E -w file.cl-type reference.cl-type
</code></pre></div></div><p>You should implement all of the typing rules in the Cool Reference Manual. There are also a number of other rules and corner cases you have to check (e.g., no class can inherit from Int, you cannot redefine a class, you cannot have an attribute named self, etc.). They are sprinkled throughout the manual. Check everything you possibly can.</p><h3 id="pa2c1--creating-pa2-tests"> <a href="#pa2c1--creating-pa2-tests" class="anchor-heading" aria-labelledby="pa2c1--creating-pa2-tests"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PA2c1 — Creating PA2 Tests</h3><p>PA2c1 is a preliminary testing exercise that introduces a form of <a href="http://en.wikipedia.org/wiki/Test-driven_development">test-driven development</a> or <a href="http://en.wikipedia.org/wiki/Mutation_testing">mutation testing</a> into our software development process and requires you to construct a high-quality test suite.</p><p>The goal of PA2c1 is to leave you with a high-quality test suite of Cool programs that you can use to evaluate your own PA2 type checker. Writing a type checker requires you to consider many corner cases when reading the formal and informal typing rules in the Cool Reference Manual. While you you can check for correct “positive” behavior by comparing your typechecker’s output to the reference compiler’s output on existing “good” Cool programs, it is comparatively harder to check for “negative” behavior (i.e., correctly reporting ill-typed Cool programs).</p><p>If you fail to construct a rich test suite of syntactically-valid but semantically-invalid programs you will face a frustrating series of “you fail held-out negative test x” reports for PA2 proper, which can turn into unproductive guessing games. Because students often report that this is frustrating (even though it is, shall we say, infinitely more realistic than making all of the post-deployment tests visible in advance), the PA2c1 preliminary testing exercise provides a structured means to help you get started with the construction of a rich test suite.</p><p>The course staff have produced 20 variants of the reference compiler, each with a secret <a href="http://en.wikipedia.org/wiki/Fault_injection">intentionally-introduced defect</a> related to type-checking. A high-quality test suite is one that reveals each introduced defect by showing a difference between the behavior of the true reference compiler and the corresponding buggy version. You desire a high-quality test suite to help you gain confidence in your own PA2 submission.</p><p>For PA2c1, you must produce syntactically valid Cool programs (test cases). There are 20 separate held-out seeded type-checker bugs waiting on the grading server. For each bug, if one of your tests causes the reference and the buggy version to produce difference output (that is, either a different <code class="language-plaintext highlighter-rouge">.cl-type</code> file or a different error report), you win: that test has revealed that bug. For full credit your tests must reveal at least 15 of the 20 unknown defects.</p><p>The secret defects that we have injected into the reference compiler correspond to common defects made by students in PA2. Thus, if you make a rich test suite for PA2c1 that reveals many defects, you can use it on your own PA2 submission to reveal and fix your own bugs!</p><h3 id="video-guides"> <a href="#video-guides" class="anchor-heading" aria-labelledby="video-guides"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Video Guides</h3><p>This assignment is a mildly-modified version of <a href="https://web.eecs.umich.edu/~weimerw/">Wes Weimer</a>’s <a href="https://weimer.github.io/csci2320/pa4.html">similar assignment</a>. Wes has kindly prepared a number of video guides to help students get started on…:</p><ul><li><a href="https://youtu.be/2CMhLddBt1M">PA2c1</a> (which his course calls “PA4t”)<li><a href="https://youtu.be/Wa9zMygcv_M">PA2c2</a> (which his course calls “PA4c”)<li><a href="https://youtu.be/Oxpgrkmsxhg">PA2 (full)</a> (which his course calls “PA4”)</ul><p>(Aside: the reason that the type checker in Wes’ class is “PA4” but in this class it’s “PA2” is that Wes can’t make the assumption that students have built a lexer and parser before (as NJIT students hopefully did in CS 280). So, Wes’ course includes a “PA2: Lexer” and “PA3: Parser” before this assignment. That leaves Wes’ course with less time at the end of the course, so they build a Cool <em>interpreter</em> rather than a compiler—meaning that their course misses out on code generation and optimization, which in my opinion are the most interesting parts.)</p><h3 id="what-to-turn-in-for-pa2c1"> <a href="#what-to-turn-in-for-pa2c1" class="anchor-heading" aria-labelledby="what-to-turn-in-for-pa2c1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What to Turn In For PA2c1</h3><p>For PA2c1 you should turn in (electronically):</p><ul><li>A set of up to 99 .cl files: Cool typechecker testcases.<ul><li>Each testcase you submit must be syntactically valid (i.e., must pass <code class="language-plaintext highlighter-rouge">cool --parse</code>).<li>Each testcase you submit may be semantically valid or semantically invalid, your choice (i.e., it can pass or fail <code class="language-plaintext highlighter-rouge">cool --type</code>).<li>If you submit more than 99 tests, some will be ignored.</ul></ul><p>Hint: because you can find “positive” bugs in your typechecker more easily (e.g., by running your typechecker on the correct Cool programs from <code class="language-plaintext highlighter-rouge">cool-examples.zip</code>), the PA2c1 exercise is strongly biased toward “negative” bugs (i.e., the secret buggy typecheckers usually fail to report certain semantic errors).</p><h3 id="pa2c2--typechecking-everything-but-expressions"> <a href="#pa2c2--typechecking-everything-but-expressions" class="anchor-heading" aria-labelledby="pa2c2--typechecking-everything-but-expressions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PA2c2 — Typechecking Everything But Expressions</h3><p>PA2c2 is a checkpoint for your full semantic analyzer implementation (unlike PA2c1, which only requires you to write test cases). The typechecker is a large project (and a large part of your grade), so it behooves you to start it early. PA2c2 exists so that students are motivated to have <em>something</em> working earlier, because we know that students are deadline-driven :)</p><p>For PA2c2 you should turn in an early version of PA2 that does the following:</p><ul><li>Reads in the <code class="language-plaintext highlighter-rouge">.cl-ast</code> file given as a command-line argument.<ul><li>You do not need to use a parser generator to read in the <code class="language-plaintext highlighter-rouge">.cl-ast</code> file — its format was specifically chosen to make it easy to read with just some mutually-recursive procedures. It should take you (much) less than 150 lines to read in the <code class="language-plaintext highlighter-rouge">.cl-ast</code> file.</ul><li>Does every bit of typechecking and semantic analysis possible <em>without typechecking expressions</em>.<ul><li>Thus you should not annotate types in initializer expressions in the class map.</ul><li>Prints out error messages as normal.<li>Outputs <em>only the class map</em> to <code class="language-plaintext highlighter-rouge">.cl-type</code> if there are no errors.<ul><li>You can use the <code class="language-plaintext highlighter-rouge">--class-map</code> command-line argument to get the reference compiler to spit out the class map after typechecking (for comparison).</ul></ul><p>Thus you should build the class hierarchy and check everything related to that. For example:</p><ul><li>Check to see if a class inherits from <code class="language-plaintext highlighter-rouge">Int</code> (etc.).<li>Check to see if a class inherits from an undeclared class.<li>Check for cycles in the class hierarchy.<li>Check for duplicate method or attribute definitions in the same class.<li>Check for a child class that redefines a parent method but changes the parameters.<li>Check for a missing method <code class="language-plaintext highlighter-rouge">main</code> in class <code class="language-plaintext highlighter-rouge">Main</code>.<li>Check for <code class="language-plaintext highlighter-rouge">self</code> and <code class="language-plaintext highlighter-rouge">SELF_TYPE</code> mistakes in classes and methods.<li>This list is <strong>not exhaustive</strong> – read the Cool Reference Manual carefully and find everything you might check for without typechecking expressions.<li>Basically, you’ll look at classes, methods and attibutes (but not method bodies).</ul><hr /><p><strong>Question</strong>: What’s the exact list of errors I have to check for in PA2c2?</p><p><strong>Answer 1</strong>: No such list is provided! Part of the assignment is thinking up all possible checks that do not involve expressions. <br /><strong>Answer 2</strong>: Use the test cases you made for PA2c1.</p><hr /><h3 id="what-to-turn-in-for-pa2c2"> <a href="#what-to-turn-in-for-pa2c2" class="anchor-heading" aria-labelledby="what-to-turn-in-for-pa2c2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What to Turn In For PA2c2</h3><p>You must turn in these files:</p><ul><li><code class="language-plaintext highlighter-rouge">source_files</code> — your implementation, including exactly one of the following files:<ul><li><code class="language-plaintext highlighter-rouge">main.c</code><li><code class="language-plaintext highlighter-rouge">main.py</code><li><code class="language-plaintext highlighter-rouge">main.cpp</code><li><code class="language-plaintext highlighter-rouge">Main.java</code><li><code class="language-plaintext highlighter-rouge">main.kt</code><li><code class="language-plaintext highlighter-rouge">main.rs</code><li><code class="language-plaintext highlighter-rouge">Main.scala</code><li><code class="language-plaintext highlighter-rouge">main.ml</code><li><code class="language-plaintext highlighter-rouge">main.hs</code></ul></ul><h3 id="what-to-turn-in-for-pa2"> <a href="#what-to-turn-in-for-pa2" class="anchor-heading" aria-labelledby="what-to-turn-in-for-pa2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What to Turn In For PA2</h3><p>You must turn in these files:</p><ul><li><code class="language-plaintext highlighter-rouge">source_files</code> — your implementation, including exactly one of the following files:<ul><li><code class="language-plaintext highlighter-rouge">main.c</code><li><code class="language-plaintext highlighter-rouge">main.py</code><li><code class="language-plaintext highlighter-rouge">main.cpp</code><li><code class="language-plaintext highlighter-rouge">Main.java</code><li><code class="language-plaintext highlighter-rouge">main.kt</code><li><code class="language-plaintext highlighter-rouge">main.rs</code><li><code class="language-plaintext highlighter-rouge">Main.scala</code><li><code class="language-plaintext highlighter-rouge">main.ml</code><li><code class="language-plaintext highlighter-rouge">main.hs</code></ul><li><code class="language-plaintext highlighter-rouge">readme.txt</code> - your README file<li><code class="language-plaintext highlighter-rouge">good.cl</code> - a novel positive test case<li><code class="language-plaintext highlighter-rouge">bad1.cl</code> - a novel negative test case<li><code class="language-plaintext highlighter-rouge">bad2.cl</code> - a novel negative test case<li><code class="language-plaintext highlighter-rouge">bad3.cl</code> - a novel negative test case</ul><h3 id="grading-rubric"> <a href="#grading-rubric" class="anchor-heading" aria-labelledby="grading-rubric"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Grading Rubric</h3><p>PA2 Grading (out of 100 points):</p><ul><li>66 points — for autograder tests<ul><li>The scoring is directly proportional to the number of autograder tests you pass.</ul><li>5 points — for a correct PA2c1 submission<li>5 points — for a correct PA2c2 submission<li>8 points — for a clear description in your README<ul><li>8 — thorough discussion of design decisions (e.g., handling of the class hierarchy, case and new and dispatch) and choice of test cases; a few paragraphs of coherent English sentences should be fine<li>4 — vague or hard to understand; omits important details<li>0 — little to no effort, or submitted an RTF/DOC/PDF file instead of plain TXT</ul><li>8 points — for valid and novel <code class="language-plaintext highlighter-rouge">good.cl</code>, <code class="language-plaintext highlighter-rouge">bad1.cl</code>, <code class="language-plaintext highlighter-rouge">bad2.cl</code> and <code class="language-plaintext highlighter-rouge">bad3.cl</code> files<ul><li>8 — wide range of test cases added, stressing most Cool features and three error conditions, novel files (note: it is acceptable for these test cases to be a selection of the best ones from your PA2c1 submission: that’s what we expect)<li>4 — added some tests, but the scope not sufficiently broad<li>0 — little to no effort, or course files resubmitted as tests</ul><li>8 point — for code cleanliness<ul><li>8 — code is mostly clean and well-commented<li>4 — code is sloppy and/or poorly commented in places<li>0 — little to no effort to organize and document code</ul></ul><hr><footer><p class="text-small text-grey-dk-100 mb-0">&copy; 2022-2025 Martin Kellogg, Wes Weimer, Jonathan Bell, Adeel Bhutta and Mitch Wand. Released under the <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a> license</p></footer></div></div><div class="search-overlay"></div></div>
