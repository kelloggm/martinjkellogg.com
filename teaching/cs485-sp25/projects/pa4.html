<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><link rel="shortcut icon" href="/martinjkellogg.com/teaching/cs485-sp25/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/martinjkellogg.com/teaching/cs485-sp25/assets/css/just-the-docs-default.css"> <script src="/martinjkellogg.com/teaching/cs485-sp25/assets/js/vendor/lunr.min.js"></script> <script src="/martinjkellogg.com/teaching/cs485-sp25/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>PA4: Optimizer | CS 485 Compilers (Sp25)</title><meta name="generator" content="Jekyll v3.9.2" /><meta property="og:title" content="PA4: Optimizer" /><meta name="author" content="Martin Kellogg" /><meta property="og:locale" content="en_US" /><meta name="description" content="The course website for NJIT CS 485 in Spring 2025, as taught by Martin Kellogg" /><meta property="og:description" content="The course website for NJIT CS 485 in Spring 2025, as taught by Martin Kellogg" /><link rel="canonical" href="https://kelloggm.github.io/martinjkellogg.com/teaching/cs485-sp25/projects/pa4.html" /><meta property="og:url" content="https://kelloggm.github.io/martinjkellogg.com/teaching/cs485-sp25/projects/pa4.html" /><meta property="og:site_name" content="CS 485 Compilers (Sp25)" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="PA4: Optimizer" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Martin Kellogg"},"description":"The course website for NJIT CS 485 in Spring 2025, as taught by Martin Kellogg","headline":"PA4: Optimizer","url":"https://kelloggm.github.io/martinjkellogg.com/teaching/cs485-sp25/projects/pa4.html"}</script><body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"><title>Search</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"><title>Document</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><title id="svg-external-link-title">(external link)</title><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> </svg><div class="side-bar"><div class="site-header"> <a href="/martinjkellogg.com/teaching/cs485-sp25/" class="site-title lh-tight"> CS 485 Compilers (Sp25) </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Programming Assignments category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/" class="nav-list-link">Programming Assignments</a><ul class="nav-list "><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/pa1.html" class="nav-list-link">PA1: Rosetta Stone</a><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/pa2.html" class="nav-list-link">PA2: Semantic Analyzer</a><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/pa3.html" class="nav-list-link">PA3: Code Generator</a><li class="nav-list-item active"><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/pa4.html" class="nav-list-link active">PA4: Optimizer</a></ul><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Tutorials category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/martinjkellogg.com/teaching/cs485-sp25/tutorials/" class="nav-list-link">Tutorials</a><ul class="nav-list "><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/tutorials/reading-papers.html" class="nav-list-link">How to Read a Paper (Useful for "Optional" Readings)</a><li class="nav-list-item "><a href="/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html" class="nav-list-link">Ubuntu Setup Guide</a></ul><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/calendar/" class="nav-list-link">Calendar</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/exam/" class="nav-list-link">Exams</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/staff/" class="nav-list-link">Staff</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/languages/" class="nav-list-link">Supported Languages</a><li class="nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/about/" class="nav-list-link">Syllabus</a></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div class="search"><div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search CS 485 Compilers (Sp25)" aria-label="Search CS 485 Compilers (Sp25)" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label></div><div id="search-results" class="search-results"></div></div><nav aria-label="Auxiliary" class="aux-nav"><ul class="aux-nav-list"><li class="aux-nav-list-item"> <a href="https://kelloggm.github.io/martinjkellogg.com/teaching/cs485-sp25/crm/onepage/crm-onepage.html" class="site-button" > CRM </a><li class="aux-nav-list-item"> <a href="https://discord.com/channels/1329854456967467048/1329854456967467051" class="site-button" > Discord </a><li class="aux-nav-list-item"> <a href="https://www.gradescope.com/courses/956674" class="site-button" > Gradescope </a></ul></nav></div><div id="main-content-wrap" class="main-content-wrap"><nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"><a href="/martinjkellogg.com/teaching/cs485-sp25/projects/">Programming Assignments</a><li class="breadcrumb-nav-list-item"><span>PA4: Optimizer</span></ol></nav><div id="main-content" class="main-content" role="main"><h2 class="fs-6" id="pa4-optimizer"> <a href="#pa4-optimizer" class="anchor-heading" aria-labelledby="pa4-optimizer"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PA4: Optimizer <strong class="label label-red">Due May 15, 2025, 2:30PM EDT.</strong></h2><p>You are advised to complete this assignment in the same language you used for PA3. Your starter code for this assignment is typically your final PA3 submission. You are permitted to, but strongly discouraged from, starting over without using your PA3 submission. If you plan to do so, you should discuss the situation with the instructor and/or TAs first.</p><p>You may work in a team of two people for this assignment if and only if you worked in a team for PA3 and both teammates are still willing to work together. If either teammate does not want to work together anymore, both of you <em>must</em> work alone (but you may each start from a copy of the shared PA3 starter code). The course staff are not responsible for finding you a willing teammate. You are always permitted to work alone, if you choose.</p><h3 id="goal"> <a href="#goal" class="anchor-heading" aria-labelledby="goal"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Goal</h3><p>For this assignment you will write an <em>optimizing</em> code generator. This typically involves transforming the abstract syntax tree into a control-flow graph of three-address code and applying a number of dataflow analyses and optimizations. In addition, students typically apply pattern-matching optimizations at the AST level and peephole optimizations at the assembly level. You have a lot of <strong>creative freedom</strong> in this assignment to choose the optimizations that you want to implement. There is no “one true answer”: any and every optimization that you can think of might be useful.</p><p>In all cases, the optimized assembly code you emit must produce <strong>exactly the same</strong> result as the reference compiler. The first rule of optimization is “don’t break the program”.</p><p>You do not have to worry about “malformed source code” because the semantic analyzer (from PA2) has already ruled out bad programs.</p><p>This assignment is an explicit competition. You will receive more credit if your optimizer is “better” than that of other students in terms of the number of machine cycles that your generated assembly code takes to execute various test programs.</p><h3 id="summary-of-checkpoints"> <a href="#summary-of-checkpoints" class="anchor-heading" aria-labelledby="summary-of-checkpoints"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Summary of Checkpoints</h3><p>There is one checkpoint for the Optimizer:</p><ul><li><strong>PA4c1</strong> requires you to implement a dead-code eliminator for Cool three-address code (i.e., the same format as PA3c2). This dead-code eliminator need not be part of the same codebase as the rest of PA4 – the specification for it (see below) is standalone. However, your final PA4 submission is required to include a dead-code eliminator, so we strongly suggest that you integrate PA4c1 into your existing codebase. For example, you might have a command-line switch in your main codebase that makes it match the PA4c1 specification, which you enable by default when submitting PA4c1. This checkpoint is due on <strong>Monday, April 28</strong>.<li><strong>PA4 (full)</strong> will be evaluated on the day of the final exam. You will automatically make a submission to PA4 when you submit PA3 (i.e., we will add your PA3 submission to the leaderboard). You can continue to make changes to your optimizer and resubmit it as many times as you’d like between the PA3 and PA4 deadlines.</ul><h3 id="pa4c1-dead-code-elimination"> <a href="#pa4c1-dead-code-elimination" class="anchor-heading" aria-labelledby="pa4c1-dead-code-elimination"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PA4c1: Dead Code Elimination</h3><p>PA4c1 is a stand-alone checkpoint assignment designed to encourage you to write a <a href="http://en.wikipedia.org/wiki/Dead_code_elimination">dead-code eliminator</a> for <a href="../pa3.html#pa3c2-three-address-code-generator">Cool three-address code</a>. Since your final PA4 submission is <em>required</em> to include a dead-code eliminator, we encourage you to use this checkpoint as an excuse to implement one. However, if it would be more convenient for your compiler’s design to do dead-code elimination on another IR, you <em>can</em> skip this checkpoint (but we don’t recommend it, and it will cost you a few points). Come talk to the course staff if you’re unsure.</p><p>For this checkpoint, your dead-code eliminator should implement a “global” <a href="https://en.wikipedia.org/wiki/Live-variable_analysis">live-variable analysis</a> (like the one discussed in class); recall that “global”, in the context of optimization, means “considers a single method at once.”</p><h4 id="specification"> <a href="#specification" class="anchor-heading" aria-labelledby="specification"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Specification</h4><p>You should submit a program that takes a single command-line argument (e.g., <code class="language-plaintext highlighter-rouge">file.cl-tac</code>). That argument will be an ASCII text Cool Three Address Code file (as described in the PA3c2 specification) corresponding to a single method. The cl-tac file will always be well-formed (i.e., there will be no errors in the cl-tac file). Your program must output a revised, valid .cl-tac file to standard output. The output should be the same as the input but with dead code removed. Your program will consist of a number of source files, all in the same programming language. We suggest (but do not require) that it be a variant of your main PA3/PA4 codebase; we would implement this specification by setting a flag in our compiler’s codebase.</p><h4 id="dead-code-elimination"> <a href="#dead-code-elimination" class="anchor-heading" aria-labelledby="dead-code-elimination"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dead Code Elimination</h4><p>A variable is <strong>live</strong> if it may be needed in the future. That is, an assignment to variable <em>v</em> at point <em>p</em> is live if there exists a path from <em>p</em> to the function exit along which <em>v</em> is read before it is overwritten.</p><p>For example, consider the following TAC:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a &lt;- int 1
b &lt;- int 3
c &lt;- + a b 
d &lt;- int 7
retval &lt;- call out_int c 
return retval 
</code></pre></div></div><p>On the fourth line, the assignment to <em>d</em> is dead because <em>d</em> is not subsequently used. Dead assignments can be removed. Often eliminating one piece of dead code can reveal additional dead code. For example, consider this fragment of TAC:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a &lt;- int 1
b &lt;- int 3
c &lt;- + a b 
d &lt;- int 7
e &lt;- + d d 
retval &lt;- call out_int c 
return retval 
</code></pre></div></div><p>In above example, the assignment to <em>d</em> is <strong>not</strong> dead (yet!) but the assignment to <em>e</em> is dead. Once the assignment to <em>e</em> is eliminated, the assignment to <em>d</em> becomes dead and can then be eliminated. Thus, live variable analysis and dead code elimination must be repeated until nothing further changes.</p><p>You should use the <a href="http://en.wikipedia.org/wiki/Live_variable_analysis">live variable analysis</a> form of <a href="http://en.wikipedia.org/wiki/Data-flow_analysis">data-flow analysis</a> to determine which assignments are dead code. We discussed this topic in class (in the “Global Optimization” and “Dead Code Elimination” lectures), but you are not required to follow the lecture slides’ formalism: you may use any of the (many) equivalent analyses described online, in the textbook, etc - as long as you preserve the program’s semantics and remove dead code.</p><p>Note that function calls with I/O side effects should never be eliminated.</p><h4 id="basic-blocks-and-control-flow-graphs"> <a href="#basic-blocks-and-control-flow-graphs" class="anchor-heading" aria-labelledby="basic-blocks-and-control-flow-graphs"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Basic Blocks and Control-Flow Graphs</h4><p>A <a href="http://en.wikipedia.org/wiki/Basic_block">basic block</a> is a sequence of instructions with only one control-flow entry and one control-flow exit. That is, once you start executing the instructions in a basic block, you must execute all of them — you cannot jump out early or jump in half-way through.</p><p>A <em>local</em> dataflow analysis operates on basic blocks. As part of this checkpoint, you will need to implement a local dead-code eliminator.</p><p>As part of this assignment you will also implement a <em>global</em> dataflow analysis that operates on multiple basic blocks (that together form one entire method). A <a href="http://en.wikipedia.org/wiki/Control_flow_graph">control-flow graph</a> is a graph in which the nodes are basic blocks and the edges represent potential control flow.</p><p>You are not required to use these formalisms, exactly, in the your implementation. However, we <em>strongly</em> suggest that you explicitly represent the basic blocks and control-flow graph of the input TAC program.</p><h4 id="commentary"> <a href="#commentary" class="anchor-heading" aria-labelledby="commentary"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Commentary</h4><p>A successful implementation of this checkpoint will have the following stages:</p><ol><li>Deserialize the input .cl-tac file<li>Identify basic blocks and construct the control-flow graph<li>Repeat until nothing changes:<ol><li>Perform global live variable analysis on the control-flow graph<ul><li>This involves local live variable analysis on individual statements or basic blocks</ul><li>Eliminate dead code</ol><li>Serialize the result to standard output in .cl-tac format</ol><p>You can do basic testing as follows:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cool --tac file.cl --out original
$ cool --tac --opt file.cl --out ref_optimized
$ my-dce original.cl-tac &gt; my_optimized.cl-tac
$ cool ref_optimized.cl-tac &gt; optimized.output
$ cool my_optimized.cl-tac &gt; my.output
$ diff optimized.output my.output
$ cool --profile ref_optimized.cl-tac | grep STEPS
$ cool --profile my_optimized.cl-tac | grep STEPS
</code></pre></div></div><p>Passing <code class="language-plaintext highlighter-rouge">--opt</code> and <code class="language-plaintext highlighter-rouge">--tac</code> to the reference compiler will cause the reference compiler to perform dead code elimination before emitting the .cl-tac file.</p><h4 id="grading"> <a href="#grading" class="anchor-heading" aria-labelledby="grading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Grading</h4><p>There are fifteen test cases for PA4c1 (they are the same test cases, in the same order, that were used for PA3c3). We will run each with 10 inputs. You <em>lose</em> one-tenth of a point for each input for which you do not produce the correct output, to a miniumum of zero. You gain one-tenth of a point for each test input for which your generated cl-tac, when simulated, executes fewer instructions than a threshold chosen by the course staff. Your score is rounded down to the nearest integer.</p><h3 id="pa4-full-the-optimizer"> <a href="#pa4-full-the-optimizer" class="anchor-heading" aria-labelledby="pa4-full-the-optimizer"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PA4 (full): the Optimizer</h3><p>The full PA4 assignment is an explicit competition: your goal is to produce faster assembly programs (while preserving semantics) than both your classmates’ compiler and our reference compiler. We provide a <strong>pseudo-anonymous leaderboard</strong> for this assignment. Your submissions will automatically appear on the leaderboard.</p><p>The leaderboard has three kinds of submissions:</p><ul><li>student submissions. These are labeled with a student-chosen pseudonym.<li>reference submissions. These are labeled “reference” and “refernce opt”; they correspond directly to version 1.41 of the reference compiler without the <code class="language-plaintext highlighter-rouge">--opt</code> flag and with the <code class="language-plaintext highlighter-rouge">--opt</code> flag, respectively. You must beat these for full credit on the assignment.<li>“boss” submissions, which are graciously provided by people who have taken this class or a similar one in the past (including your professor). Beating these is totally optional, but you might enjoy gloating.</ul><h4 id="specification-1"> <a href="#specification-1" class="anchor-heading" aria-labelledby="specification-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Specification</h4><p>You must create three artifacts:</p><ol><li>A program that takes a single command-line argument (e.g., <code class="language-plaintext highlighter-rouge">file.cl-type</code>). That argument will be an ASCII text Cool class map, implementation map, parent map and annotated AST file (as described in PA2). Your program must emit x86-64 Assembly Language (<code class="language-plaintext highlighter-rouge">file.s</code>). Your program will consist of a number of source files.<ol><li>Compiling <code class="language-plaintext highlighter-rouge">file.s</code> with <code class="language-plaintext highlighter-rouge">gcc -static -no-pie</code> on a 64-bit x86 Linux system must produce an executable that, when run, produces the correct output for <code class="language-plaintext highlighter-rouge">file.cl</code> according to Cool’s operational semantics.<li>You will only be given <code class="language-plaintext highlighter-rouge">.cl-type</code> files from programs that pass the semantic analysis phase of the reference compiler. You are not responsible for correctly handling (1+”hello”) programs.<li>Your optimizer <em>must</em> construct a control-flow graph representation, perform an intraprocedural data-flow analysis, and use the results to eliminate dead code. (You may be more precise, for example with an interprocedural analysis, if you like.) This single optimization is necessary but not sufficient — you must also do additional optimizations.</ol><li>A plain ASCII text file called <code class="language-plaintext highlighter-rouge">readme.txt</code> describing your optimization design decisions and choice of benchmarks. You must also describe your approach to the control flow graph, dataflow analysis and dead code elimination requirement. You should describe any other optimizations you carried out. See the grading rubric. A few paragraphs should suffice.<li>Two benchmarks <code class="language-plaintext highlighter-rouge">benchmark1.cl</code> and <code class="language-plaintext highlighter-rouge">benchmark2.cl</code>. Each benchmark should be a valid Cool program of reasonable runtime. Optimizers will be graded on the average of their performance on a pool of programs: that pool contains some baseline Cool programs as well as all benchmarks submitted by participants (see the section on “Benchmark Submission”, below). You can thus “stack the deck” in your favor by constructing programs that you are very good at optimizing but that others may not be able to handle.</ol><h4 id="pseudonym-rules"> <a href="#pseudonym-rules" class="anchor-heading" aria-labelledby="pseudonym-rules"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Pseudonym Rules</h4><p>Gradescope will ask you to provide a pseudonym for the leaderboard. You may select any string, subject to the following rules:</p><ul><li>the string must not make fun of someone enrolled in the class (yourself or others). This rule will be enforced harshly, so err on the side of caution.<li>the string cannot violate university policies and/or laws related to hate speech or other offensive material.<li>the string cannot be, in the view of the instructor, “unsafe for work”.</ul><p>Submissions that violate these rules will receive scores of zero, and the course staff may take further action against you (including referring you to the dean of students, failing you, etc.) if you violate them. We encourage you to choose a humorous, non-identifying name for your team. Be as creative as you like, so long as it’s “safe for work”. But please do not make me regret giving you the freedom to pick a name.</p><p>You’re explicitly permitted to lie to your classmates about which pseudonym refers to your compiler. You are also permitted to use more than one pseudonym, but please keep the number of pseudonyms relatively small.</p><p>The leaderboard displays the language that your compiler is implemented in. If you want this not to be displayed (e.g., for anonymity), include an empty file named <code class="language-plaintext highlighter-rouge">anonymous</code> in your submission; if you do, the language column will be “???” instead of the name of the language.</p><h4 id="leaderboard-scoring"> <a href="#leaderboard-scoring" class="anchor-heading" aria-labelledby="leaderboard-scoring"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Leaderboard scoring</h4><p>Our autograder will evaluate each submission along four axes:</p><ul><li>your <strong>correctness score</strong> <em>C</em> is the fraction of PA3 tests for which your compiler’s generated x86 code and the x86 code generated by the reference compiler (without <code class="language-plaintext highlighter-rouge">--opt</code>) produce the same output. <em>C</em> is a real value in the range [0, 1].<li>your <strong>benchmark correctness score</strong> <em>B</em> is the fraction of additional benchmarks for which your compiler’s generated x86 code and the x86 code generated by the reference compiler (without <code class="language-plaintext highlighter-rouge">--opt</code>) produce the same output. <em>B</em> is a real value in the range [0, 1].<li>your <strong>quickness score</strong> <em>Q</em> is the relative improvement of your compiler’s generated assembly over the generated assembly from the reference compiler (again, on a set of Cool program + test input pairs) in terms of wall-clock time at nanosecond precision (repeated one hundred times to account for timing variance). We measure this for each test case + input pair individually, and then compute the geometric mean of all pairs for which you got the same output as the reference compiler. The set of pairs used for computing <em>Q</em> is the union of the sets used for <em>C</em> and <em>B</em>. <em>Q</em> is a positive real value. It may be either greater or less than 1; a value greater than 1 indicates that the code you produce is <em>slower</em> than the reference compiler; less than 1 indicates that your code is <em>faster</em>.<li>your <strong>size score</strong> <em>Z</em> is the relative improvement of your compiler’s generated assembly over the reference compiler, in terms of code size. We measure this by comparing the size of the binary generated by assembling and linking your <code class="language-plaintext highlighter-rouge">.s</code> file, using the command <code class="language-plaintext highlighter-rouge">stat -c %s</code> to the binary generated from the <code class="language-plaintext highlighter-rouge">.s</code> file produced by the reference for each test case that you pass, and then taking the geometric mean of the results. It may be either greater or less than 1; a value greater than 1 indicates that the code you produce is <em>larger</em> than the reference compiler; less than 1 indicates that your code is <em>smaller</em>.</ul><p>Your <strong>overall score</strong> <em>S</em> is defined by the following formula (higher is better):</p><p><em>S = C^2 * B * (1/Q)^2 * 1/Z</em></p><p>Some things to note:</p><ul><li>the exponents represent the relative importance of the optimization targets: correctness is the most important, followed by speed, followed by binary size.<li>getting a test case incorrect hurts you a lot more than being fast<li>this formula is subject to revision if I decide that it doesn’t do a good job of differentiating compilers based on my subjective assessment of their performance<li>the use of wall-clock time for measure Q score is subject to change, if I manage to convince Gradescope to let me meaure clock cycles instead. While wall-clock time can show some variance, please don’t spam the submission server trying to get a mildly-faster time. I’ll impose submission caps if y’all start doing this.</ul><p>Submissions will be ranked on the leaderboard by their overall score, but all of these scores will be visible.</p><h4 id="baseline-benchmarks"> <a href="#baseline-benchmarks" class="anchor-heading" aria-labelledby="baseline-benchmarks"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Baseline Benchmarks</h4><p>A baseline set of indicative benchmarks is available here:</p><ul><li><a href="../assets/cool-optimizer-benchmarks.zip">cool-optimizer-benchmarks.zip</a></ul><p>Your program will be judged on the baseline set as well as programs submitted by you and other students (see “Benchmark Submission”). The baseline benchmarks were chosen so that reasonable optimizations, such as those discussed in class, would yield non-trivial improvements. Some of them are “realistic” (e.g., matrix multiplication, calculating pi, …) while others are clearly “synthetic”. Our initial set of benchmarks <em>B</em> contains all of these benchmarks <em>and some other, held-out benchmarks</em>.</p><h4 id="benchmark-submission-100-optional"> <a href="#benchmark-submission-100-optional" class="anchor-heading" aria-labelledby="benchmark-submission-100-optional"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Benchmark Submission (100% Optional!)</h4><p>You may submit new benchmarks for inclusion in the set of Cool programs used to compute the benchmark score <em>B</em> (and, thus, the quickness and size scores) using <a href="https://forms.gle/CCZVC2ZZ3F6MczF8A">this form</a>. The instructor will check the responses to this form once per “business day” while the optimizer competition is running. You will not be notified whether your benchmark has been included. If you make multiple low-quality submissions to this form, I may (at my discretion) choose not to evaluate future submissions.</p><p>It is completely optional to submit benchmarks via this form. However, only benchmarks submitted via this form will be considered for addition to the set of benchmarks used on the leaderboard. You are required to provide two benchmarks with your final submission, but they need not have been submitted via this form.</p><p>Submitted benchmarks <strong>must</strong> take 50,000 instructions or fewer to execute via the reference compiler with <code class="language-plaintext highlighter-rouge">–asm –profile</code>. <strong>You</strong> are responsible for verifying that this is the case before submitting the form.</p><p>We guarantee that benchmarks will have consistent numbering on the autograder, even as we add additional, student-submitted benchmarks. For example, if a benchmark is ever labeled “benchmark 9” on the autograder, then “benchmark 9” on the autograder will always refer to that benchmark.</p><h4 id="commentary-and-suggestions"> <a href="#commentary-and-suggestions" class="anchor-heading" aria-labelledby="commentary-and-suggestions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Commentary and Suggestions</h4><p>Different optimizations work best on different representations. You may want to consider:</p><ul><li>Use your CFG for additional dataflow analyses, such as:<ul><li>Constant folding and propagation<li>Common subexpression elimination<li>Eliminating checks when a value cannot possibly be “void” (null) or “0”</ul><li>General AST pattern-matching optimizations, such as:<ul><li>Loop unrolling<li>Loop-invariant code motion<li>Inlining method or constructor calls<li>Constant string merging</ul><li>Object-oriented optimizations, such as:<ul><li>Constant constructors<li>“Unboxing” Integers<li>“Unboxing” Bools, Jump Threading for conditionals<li>Receiver class optimization<li>Removing unused methods and fields</ul><li>Assembly-level optimizations, such as:<ul><li>Peephole optimization<li>Strength reduction<li>Code layout optimizations</ul><li>Register optimizations, such as:<ul><li>Using additional registers as the first few stack slots<li>Making your own calling convention (e.g., for constructors)<li>Full-blown register allocation</ul></ul><p>If you haven’t heard of one of optimizations above, search around for it on the Internet or ask in class or during office hours.</p><h4 id="grading-1"> <a href="#grading-1" class="anchor-heading" aria-labelledby="grading-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Grading</h4><p>Grading (out of 100)</p><ul><li>64 points - for optimizer performance tests (this is the autograder “score” that Gradescope reports to you)<ul><li>-0 - quickness score better than “reference –opt” (TODO: give “reference –opt”’s quickness score here)<li>-16 - quickness score <em>Q</em> &lt; 1, but worse than “reference –opt”<li>-32 - quickness score <em>Q</em> &gt; 1 but &lt; 1.5<li>-64 - quickness score <em>Q</em> &gt; 1.5<li>-0 - size score <em>Z</em> &lt; 1<li>-4 - size score <em>Z</em> &gt; 1 but &lt; 1.5<li>-8 - size score <em>Z</em> &gt; 1.5<li>-<em>X</em> - you fail <em>X</em> PA3 tests</ul><li>-48 points - hard-coding some benchmark files rather than writing a generic optimizer<li>-24 points - total failure to implement control-flow graphs, liveness and dead code elimination<li>-12 points - partial failure to implement control-flow graphs, liveness and dead code elimination<li>16 points - for a clear description in your README<ul><li>16 - thorough discussion of design decisions (e.g., the handling of the control flow graph, live variable analysis, dead code elimination, how code generation and intermediate representations relate, other optimizations performed) and choice of benchmarks; multiple paragraphs of coherent English sentences are required<li>8 - vague or hard to understand; omits important details<li>0 - little to no effort, or submitted an RTF/DOC/PDF file instead of plain TXT</ul><li>8 points - for valid benchmark1.cl and benchmark2.cl<ul><li>8 - both examples take 50,000 instructions or fewer to execute via the reference compiler with –asm –profile<li>4 - one benchmark is not valid<li>0 - no valid benchmarks included</ul><li>8 points - for code cleanliness<ul><li>8 - code is mostly clean and well-commented<li>4 - code is sloppy and/or poorly commented in places<li>0 - little to no effort to organize and document code</ul><li>4 points - for PA4c1<ul><li>4 - 15 points on PA4c1<li>3 - 11-14 points on PA4c1<li>2 - 6-10 points on PA4c1, or you scored 0-5 on PA4c1 but your final optimizer includes DCE and beats reference with <code class="language-plaintext highlighter-rouge">--opt</code><li>1 - 1-5 points on PA4c1, or you scored 0 on PA4c1 but your final optimizer includes DCE and beats reference<li>0 - 0 points on PA4c1</ul></ul><hr><footer><p class="text-small text-grey-dk-100 mb-0">&copy; 2022-2025 Martin Kellogg, Wes Weimer, Jonathan Bell, Adeel Bhutta and Mitch Wand. Released under the <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a> license</p></footer></div></div><div class="search-overlay"></div></div>
