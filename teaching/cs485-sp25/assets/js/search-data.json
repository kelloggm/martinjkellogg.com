{"0": {
    "doc": "CS 485 Compilers (Sp25)",
    "title": "Welcome to CS 485: Compilers",
    "content": "Note: this website is an early draft and everything on it is subject to change. Schedule Builder says that this class will be on Wednesday nights, 6-9pm. That is not correct: it will be on Monday and Wednesday mornings at 10am. Sorry for the confusion! . Welcome to CS 485: Compilers! This course teaches students how to build an optimizing compiler for a Java-like object-oriented programming language. Topics include program semantics, typechecking, intermediate representations like single static assignment (SSA) form, code generation, and classic compiler optimizations including register allocation via graph coloring, peephole optimizations, and dataflow analyses. Students will also be introduced to functional programming, and its advantages for transformation-based programs like compilers that have strict correctness requirements. On this course website, you can find: . | the syllabus, | a course calendar (which includes links to the required readings), | a staff page, | links to all assignment descriptions, | useful tutorials, and | information about exams (including old/practice exams with solutions). | . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/#welcome-to-cs-485-compilers",
    "relUrl": "/#welcome-to-cs-485-compilers"
  },"1": {
    "doc": "CS 485 Compilers (Sp25)",
    "title": "CS 485 Compilers (Sp25)",
    "content": " ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/",
    "relUrl": "/"
  },"2": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": "Note: this syllabus is a draft and is subject to change. Welcome to CS 485: Compilers! This course teaches students how to build an optimizing compiler for a Java-like object-oriented programming language. Topics include program semantics, typechecking, intermediate representations like single static assignment (SSA) form, code generation, and classic compiler optimizations including register allocation via graph coloring, peephole optimizations, and dataflow analyses. Students will also be introduced to functional programming, and its advantages for transformation-based programs like compilers that have strict correctness requirements. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/",
    "relUrl": "/about/"
  },"3": {
    "doc": "Syllabus",
    "title": "Prerequisites",
    "content": "As a special topics course, this class officially has no prerequisites, and you’re signing up for it at your own risk. If this course were to be offered as a regular course, the prerequisite would be CS 280 with a grade of C or better, or the equivalent at another institution. Taking CS350 in the same semester as this course, or prior to it, is recommended but not required, provided students have some prior knowledge of assembly. Students will also benefit from taking CS 341 concurrently or before this course, because there are some relevant theory topics to optimization. Finally, this course includes a non-trivial programming project. Students who have taken a software engineering course (e.g., CS 490 with me) or otherwise have software engineering experience will probably have an easier time. The first homework assignment is due right at the drop date, and is intended to let you check that you have the basic skills that will be needed for this course. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/#prerequisites",
    "relUrl": "/about/#prerequisites"
  },"4": {
    "doc": "Syllabus",
    "title": "Topics",
    "content": ". | Functional programming | Scoping | Typechecking | Operational Semantics | Abstract Interpretation | Intermediate Representations | Code Generation | Multi-language Projects | Dead Code Elimination and Other Dataflow Analyses | Local Optimizations | Peephole Optimizations | Global Optimizations | Register Allocation | Automatic Memory Management | Exceptions | Debuggers | Linking, Loading, and Shared Libraries | . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/#topics",
    "relUrl": "/about/#topics"
  },"5": {
    "doc": "Syllabus",
    "title": "Grading and Assignments",
    "content": "Your grade is composed of the following sub-scores (in no particular order): . | 60%: Programming Projects (5% for PA1 (Rosetta Stone), 17.5% for PA2 (COOL Typechecker), 17.5% for PA3 (COOL Code Generator), 20% for PA4 (COOL Optimizing Compiler)) | 25%: Exams (10% for the mid-term, 15% for the final) | 15%: Participation &amp; Professionalism | . This class will be curved: when grading, I prefer to use the whole range available rather than scores in a tight range. That is, if an assignment is worth 10 points, I will give grades at all the points between 0 and 10. I will project your raw scores onto the final distribution twice during the semester: . | after the mid-term exam | shortly before the final exam | . You will be notified of your current projected class grade via email at each of these points. Textbook . This course uses Engineering A Compiler, 2nd edition as the primary textbook. NJIT’s library has copies available online. This textbook will be supplemented by other readings. Participation &amp; Professionalism . Your participation &amp; professionalism grade is based on your interactions with the instructors and TAs: in-class, on the course discussion forum, in office hours, etc. Remote Participation . Generally this class does not support remote participation: teaching is much more effective, in my experience, when everyone is physically present. However, I understand that sometimes you are sick, traveling, or otherwise unable to come to class. I will arrange for remote participation in any particular lecture as long as you request it at least one hour in advance (if you’re sick or in some other emergency) or 24 hours in advance (if you’re traveling or otherwise planning to be unable to come to class). Notify the instructor via email if you need to participate in a particular class remotely. Asking Questions . There is a course Discord server which you can use to ask (and answer) questions about any of the course topics or for help with the homework. Participating on Discord is optional, but if you do participate in a productive manner (especially by answering other student’s questions!), it will have a positive impact on your participation score. Office Hours and Viewing Test Cases . In addition to offering you a chance to ask questions about the lecture material, the instructor’s office hours have a unique feature that can help you with the compiler’s programming assignments (i.e., PA2-4). During the instructor’s office hours (only—TA office hours do not count), once per assignment, each team (or student, if working individually) may ask to view the content of one test case from the grading server (you’ll need to ask by test case number). Note that “per assignment” means that you can use this power only three times per semester, by default: once each for PA2, PA3, and PA4. You can only use this power in-person, and you cannot record the result electronically (e.g., by taking a photo). The idea here is to allow you to get “unstuck” if there is a particularly tricky test case that you’re struggling with on the autograder. For that reason, you can only use this power once you have made a submission to the autograder that received a nonzero score on the relevant assignment. You can gain more uses of this power per assignment by choosing a language from a language bucket other than Bucket 1; see the languages page. Programming Projects . This course has four programming projects: . | PA1: the Rosetta Stone: Students will implement the same program in four languages, one from each of the following buckets: . | Bucket 1: Languages You Already Know: Java, C, C++, or Python3 | Bucket 2: Languages With An Unusual Type System: Kotlin, Rust, or Scala | Bucket 3: Functional Languages: OCaml or Haskell | Bucket 4: Project Language: Classroom Object-Oriented Language (COOL) | . | PA2: the COOL Typechecker: the typechecker takes an AST (produced by a provided COOL parser) as input and produce either a type error or a special AST-related output format that serializes data structures produced during typechecking. | PA3: the COOL Code Generator: the code generator takes the typechecker’s output and produces x86-64 assembly. This assignment does not require any optimization, only correctness. | PA4: the COOL Optimizing Compiler: the optimizing compiler is a modified version of PA3 that also optimizes the x86-64 code that it produces. This project is judged on the speed of the generated assembly code (in addition to correctness). Students are required to 1) implement some specific optimizations, including dead code elimination, and 2) match the performance of the COOL reference compiler’s generated assembly. We will provide an anonymized leaderboard of student submissions (and reference implementations). | . Each assignment includes at least one “checkpoint” to encourage you to start early. All assignments except PA1 may be completed in pairs (but working alone is also permitted). Exams . There are two exams in this course: . | a mid-term, which is held in class about halfway through the semester (worth 10% of your course grade) | a final exam, which is held during the university-scheduled final exam slot (worth 15% of your course grade) | . Both exams will cover a range of topics discussed in lecture and/or in the mandatory readings, from any time during the semester up to the point when the exam is held. The exam will be comprehensive, covering many of the topics we discuss; I may ask about anything we covered in class or that you were supposed to read. The exam will be conducted in person. Contact the course staff privately via email if you are not able to attend for any reason (e.g., you are sick or need special accommodations) and we will arrange an alternative. See the exams page for more information. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/#grading-and-assignments",
    "relUrl": "/about/#grading-and-assignments"
  },"6": {
    "doc": "Syllabus",
    "title": "Collaboration Policy",
    "content": "Collaboration is generally encouraged in this course, as is consulting online resources. You are permitted to copy small amounts of code from any source except someone else’s copy of an assignment, as long as you cite your source. “someone else’s copy of an assignment” also includes students not currently enrolled in the course - e.g., students who took this class in previous semesters or took classes that used similar projects at other institutions. To make this more clear, here are some examples of acceptable and unacceptable collaboration on a programming assignment in this course: . Acceptable collaborations: . | Discuss problems/solutions/anything with any number of other students (as long as you don’t look at each other’s code). | Copy a short (about 10 lines or fewer - use your judgment) snippet from stackoverflow.com or a similar source, as long as you include a comment with the source URL. | Copy code written by one of your teammates during a group project for another part of the group project. | Copy code from the output of a generative AI tool such as ChatGPT that you prompted yourself, if you include a link to a record of your interaction with the model (e.g., ChatGPT’s “share” feature) as a code comment. | . Unacceptable collaborations: . | Copy code directly from another student on an individual project. | Copy code from another group on a group project. | Copy a significant portion (more than about 10 lines of code or a single method - use your judgment) of your assignment from the internet, even if you cite your source. | Copy a short snippet from the internet without citing your source. | Copy code from the output of a generative AI tool (such as ChatGPT) without citing your source | Copy code from the output of a generative AI tool prompted by someone other than you (or your teammates, for a group project) | . These rules are intended to mimic what is acceptable in industry when working as a software engineer: using the resources available to you, such as your teammates and the wider internet, is always allowed. But, it would be illegal to copy code from a competing company working on a similar product. Generative AI Policy . You are permitted to use generative AI tools on any assignment in this course, as long as you include a record of your interaction with the generative AI tool in your submission. For example, if you use ChatGPT to help you with an assignment, you are required to include the output of the “share” tool in OpenAI’s interface as a code comment in your submission. You may choose how you include your prompts and responses in your submission (e.g., it’s also permissible to include the full text of both your prompts and the output of the tool), but the following must be accessible to the course staff while grading: . | the name and version of the model being used | the full text of your prompts | the full text of the model’s responses | . Moreover, there is a specific style of prompt that is forbidden in this course when interacting with generative AI tools: you may not include text directly copied from the assignment descriptions in your prompts. Doing so is a violation of the collaboration policy and will be treated as cheating. Consequences of Violating the Collaboration Policy . (From the University) . “Academic Integrity is the cornerstone of higher education and is central to the ideals of this course and the university. Cheating is strictly prohibited and devalues the degree that you are working on. As a member of the NJIT community, it is your responsibility to protect your educational investment by knowing and following the academic code of integrity policy that is found at: http://www5.njit.edu/policies/sites/policies/files/academic-integrity-code.pdf. Please note that it is my professional obligation and responsibility to report any academic misconduct to the Dean of Students Office. Any student found in violation of the code by cheating, plagiarizing or using any online software inappropriately will result in disciplinary action. This may include a failing grade of F, and/or suspension or dismissal from the university. If you have any questions about the code of Academic Integrity, please contact the Dean of Students Office at dos@njit.edu” . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/#collaboration-policy",
    "relUrl": "/about/#collaboration-policy"
  },"7": {
    "doc": "Syllabus",
    "title": "Late Policy",
    "content": "PA1, PA2, PA3, and all checkpoint assignments may be submitted late, with an escalating “Fibonacci” penalty for each day beyond the due date. More specifically: . | Days Late | Penalty | . | 1 | 2% | . | 2 | 3% | . | 3 | 5% | . | 4 | 8% | . | 5 | 13% | . | 6 | 21% | . | n | fib(n + 2)% | . “Days Late” is always computed AoE, so if the assignment is due on a Monday and you submit it while it is still Thursday anywhere on Earth (e.g., at 5am Friday in Newark), you will be assessed a 5% penalty (3 days late). PA4 may not be submitted late, because it is due on the same day as the final exam. After that point, the course is over and I will be computing final grades. No exceptions to this policy will be made. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/#late-policy",
    "relUrl": "/about/#late-policy"
  },"8": {
    "doc": "Syllabus",
    "title": "Research",
    "content": "Your class work might be used for research purposes. For example, we may use anonymized student assignments to design algorithms or build tools to help programmers. Any student who wishes to opt out can contact the instructor or TA to do so after final grades have been issued. This has no impact on your grade in any manner. Students interested in considering undergraduate research should make an appointment with the professor to talk about it. I am happy to discuss independent study projects, paid research work over the summer, research work for credit, graduate school, or any other research related topic. To make an appointment with the professor, send a calendar invitation at a time when my calendar shows that I’m free during “regular business hours” (roughly 9-5, Monday through Friday). Include enough information in the invite so that I know why you want to talk to me. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/#research",
    "relUrl": "/about/#research"
  },"9": {
    "doc": "Syllabus",
    "title": "Acknowledgments",
    "content": "This course is heavily indebted to Wes Weimer’s courses that I took as an undergraduate: UVa’s CS 4610 and CS 4501. Thanks to Wes for sharing his materials! . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/about/#acknowledgments",
    "relUrl": "/about/#acknowledgments"
  },"10": {
    "doc": "Calendar",
    "title": "Calendar",
    "content": " ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/",
    "relUrl": "/calendar/"
  },"11": {
    "doc": "Calendar",
    "title": "Week 1",
    "content": "Jan 20 No class, MLK day Jan 22 Introduction Mandatory reading: syllabus and PA1 specification Optional reading: Spolsky’s The Perils of Java Schools . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-1",
    "relUrl": "/calendar/#week-1"
  },"12": {
    "doc": "Calendar",
    "title": "Week 2",
    "content": "Jan 27 PA1c1 due Jan 27 Functional Programming (1) Mandatory reading: Backus’ Speedcoding and the COOL Reference Manual Optional reading: Kingsbury’s Reversing the technical interview . Jan 29 Func. Prog. (2) and Intro to COOL Mandatory reading: CD 7.2.4: The ML Type System and the COOL Reference Manual (yes, again. It’s really important!) Optional reading: CD 10.6: Theoretical Foundations of Functional Languages . Jan 30 PA1c2 due ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-2",
    "relUrl": "/calendar/#week-2"
  },"13": {
    "doc": "Calendar",
    "title": "Week 3",
    "content": "Feb 3 PA1 (full) due Feb 3 Compiler Structure Mandatory reading: Engineering a Compiler (EaC), Chapter 1 Feb 5 Scoping and Types Mandatory reading: EaC 4.1 and 4.2 Feb 7 PA2c1 due ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-3",
    "relUrl": "/calendar/#week-3"
  },"14": {
    "doc": "Calendar",
    "title": "Week 4",
    "content": "Feb 10 Typechecking and Static Semantics Mandatory reading: EaC 4.3 Optional reading: TBD . Feb 12 More Static Semantics Mandatory reading: EaC 4.4 Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-4",
    "relUrl": "/calendar/#week-4"
  },"15": {
    "doc": "Calendar",
    "title": "Week 5",
    "content": "Feb 17 COOL Typechecking and Runtime Organization Mandatory reading: EaC 4.5 and 4.6 Optional reading: TBD . Feb 19 Operational Semantics Mandatory reading: Chapter 2 through 2.3.3 in Grant, Palmer, and Smith’s Principles of Programming Languages (warning: this is a long reading!) Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-5",
    "relUrl": "/calendar/#week-5"
  },"16": {
    "doc": "Calendar",
    "title": "Week 6",
    "content": "Feb 24 PA2c2 due Feb 24 Abstract Interpretation (1) Mandatory reading: Ernst’s Notes on Program Analysis, Chapter 2 through 2.12 Optional reading: EaC chapter 9 (alternative treatment to Ernst of much of the same material. I prefer Ernst, but the EaC treatment is good, too. If you’re struggling with Ernst, you should definitely read this.) . Feb 26 Abstract Interpretation (2) Mandatory reading: Ernst’s Notes on Program Analysis, 2.13 through 2.20 Optional reading: Cousot and Cousot’s Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints (note that this is an old, tough to read paper. [Ernst] 2.22 has some notes to help you make sense of the paper.) . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-6",
    "relUrl": "/calendar/#week-6"
  },"17": {
    "doc": "Calendar",
    "title": "Week 7",
    "content": "Mar 3 PA2 (full) due Mar 3 Intermediate Representations Mandatory reading: EaC 5 Optional reading: TBD . Mar 5 x86-64 Assembly Mandatory reading: EaC 6 through 6.4 Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-7",
    "relUrl": "/calendar/#week-7"
  },"18": {
    "doc": "Calendar",
    "title": "Week 8",
    "content": "Mar 10 PA3c1 due Mar 10 Code Generation (1) Mandatory reading: EaC 7 through 7.4 Optional reading: TBD . Mar 12 Code Generation (2) Mandatory reading: EaC 7.5 through end of 7 Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-8",
    "relUrl": "/calendar/#week-8"
  },"19": {
    "doc": "Calendar",
    "title": "Week 9",
    "content": "Mar 17 No Class (Spring Break) Mar 19 No Class (Spring Break) ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-9",
    "relUrl": "/calendar/#week-9"
  },"20": {
    "doc": "Calendar",
    "title": "Week 10",
    "content": "Mar 24 Mid-term Exam (in-class) see the exams page for more information Mar 26 Multi-language Projects Mandatory reading: Extending Python with C or C++ Optional reading: TBD . Mar 28 PA3c2 due ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-10",
    "relUrl": "/calendar/#week-10"
  },"21": {
    "doc": "Calendar",
    "title": "Week 11",
    "content": "Mar 31 Local Optimizations Mandatory reading: EaC 8 through 8.4 Optional reading: TBD . Apr 2 Regional and Peephole Optimizations Mandatory reading: EaC 8.5 and 11.5 Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-11",
    "relUrl": "/calendar/#week-11"
  },"22": {
    "doc": "Calendar",
    "title": "Week 12",
    "content": "Apr 7 PA3 (full) due Apr 7 Global Optimizations Mandatory reading: EaC 8.6 through end of 8 Optional reading: TBD . Apr 9 Dead Code Elimination Mandatory reading: EaC 10.1 and 10.2 Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-12",
    "relUrl": "/calendar/#week-12"
  },"23": {
    "doc": "Calendar",
    "title": "Week 13",
    "content": "Apr 14 Register Allocation (1) Mandatory reading: EaC 13 through 13.3 Optional reading: TBD . Apr 16 Register Allocation (2) Mandatory reading: EaC 13.4 through end of 13 Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-13",
    "relUrl": "/calendar/#week-13"
  },"24": {
    "doc": "Calendar",
    "title": "Week 14",
    "content": "Apr 21 PA4c1 due Apr 21 Automatic Memory Management Mandatory reading: TBD Optional reading: TBD . Apr 23 Exceptions Mandatory reading: TBD Optional reading: TBD . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-14",
    "relUrl": "/calendar/#week-14"
  },"25": {
    "doc": "Calendar",
    "title": "Week 15",
    "content": "Apr 28 Linking, Loading, and Shared Libraries Mandatory reading: CD 3.8 and 14.7 Optional reading: TBD . Apr 30 Pluggable Type Systems Mandatory reading: The Checker Framework manual, chapters 1, 2, and 3 (except 2.2.2, which you can skip). Optional reading: Kellogg et al.’s Lightweight Verification of Array Indexing and Banerjee et al.’s NullAway: Practical Type-Based Null Safety for Java . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-15",
    "relUrl": "/calendar/#week-15"
  },"26": {
    "doc": "Calendar",
    "title": "Week 16",
    "content": "May 5 Wrapup Mandatory reading: TBD May 7 No Class (Friday classes meet today) ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#week-16",
    "relUrl": "/calendar/#week-16"
  },"27": {
    "doc": "Calendar",
    "title": "Exam Week",
    "content": "May X Final Exam (in-person, location TBD) May X PA4 (full) due ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/calendar/#exam-week",
    "relUrl": "/calendar/#exam-week"
  },"28": {
    "doc": "Exams",
    "title": "Exams",
    "content": "My exams are generally cumulative: anything we’ve covered in the course up to the point at which you take the exam is fair game. I may also include questions about assigned mandatory readings, homework assignments, or any other class content that you are supposed to have viewed. My exam design philosophy is to aim for a wide range of question difficulties: I try to include both some questions that I think every student should get right and some questions that I think are difficult enough that only those who have deeply understood multiple concepts that we covered in class will even be able to answer them in a reasonable way, and everything in between. To help you prepare for this semester’s exams, below you can find links to exams from other courses that I’ve taught in previous semesters, all of which have solutions (“keys”). These exams are provided “as-is” to help you study, but please don’t over-rely on them: this is a different course, so the topics will be different! However, I generally use the same exam format in every course. CS 490 Sp23 Practice Final (key) . CS 490 Sp23 Final (key) . CS 490 Au23 Midterm (key) . CS 490 Au23 Final (key) . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/exam/",
    "relUrl": "/exam/"
  },"29": {
    "doc": "How to Read a Paper (Useful for \"Optional\" Readings)",
    "title": "What is a research paper?",
    "content": "In computer science, original research is typically published at peer-reviewed conferences. Typically these papers have between two and ten authors, and the paper typically reports on about a person-year’s worth of work (though this can vary widely). The authors will be a mix of junior and senior researchers: anyone who contributed something “intellectually significant” to the paper is typically listed as an author. In most CS sub-disciplines (including software engineering, which is the source for most of the “Optional” readings), author order is indicative: the first author is usually the person who did most of the technical work (e.g., implementing the tool, running the experiments, etc.), and the last author is typically the project leader (often, but not always, the first author’s research advisor). Often, but not always, the first author is a PhD student. To be accepted at a peer-reviewed conference, a research paper must be novel: that is, it must contain some new knowledge or evidence that the research community wasn’t aware of before. This requirement impacts how they are written: a research paper must focus on the specific thing that is novel about it, rather than surveying the field as a whole (though you can find “survey” papers that give an overview of a research area, and if you need to know the current state of a sub-field, looking for a survey paper is the way to go). ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/reading-papers.html#what-is-a-research-paper",
    "relUrl": "/tutorials/reading-papers.html#what-is-a-research-paper"
  },"30": {
    "doc": "How to Read a Paper (Useful for \"Optional\" Readings)",
    "title": "External Resources",
    "content": "I highly recommend Keshav’s How to Read a Paper if you’re not sure where to start. This short (3-page) article gives a specific strategy for attacking a research paper. I recommend Griswold’s How to Read an Engineering Research Paper. This short article is more aimed at PhD students. but it helps to explain how a research paper is structured (and might be useful to you to help understand the anatomy of a research paper). ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/reading-papers.html#external-resources",
    "relUrl": "/tutorials/reading-papers.html#external-resources"
  },"31": {
    "doc": "How to Read a Paper (Useful for \"Optional\" Readings)",
    "title": "How to Read a Paper (Useful for \"Optional\" Readings)",
    "content": "Many of the readings for this course are papers from the research literature. These papers can be intimidating if you haven’t encountered them before. This page contains some suggestions on how to read a research paper, along with links to useful external resources. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/reading-papers.html",
    "relUrl": "/tutorials/reading-papers.html"
  },"32": {
    "doc": "Supported Languages",
    "title": "Language Choice for Programming Assignments",
    "content": "PA1 groups the languages into four buckets: . | Bucket 1: Languages You Already Know: Java, C, C++, or Python3 | Bucket 2: Languages With An Unusual Type System: Kotlin, Rust, or Scala | Bucket 3: Functional Languages: OCaml or Haskell | Bucket 4: Project Language: Classroom Object-Oriented Language (COOL) | . For PA2-4, you may work in any of the above languages except COOL1. For each of those assignments, the input language is COOL (or, more accurately, a pre-parsed version of COOL). The output for PA3 and PA4 is x86-64 assembly. Details of the supported assembly language are provided below on this page. Completing PA2-4 in a language from Bucket 1 has no penalties or benefits. Completing PA2-4 in a language from Bucket 2 entitles you to one extra test case view per assignment. Completing PA2-4 in a language from Bucket 3 entitles you to one extra test case view per assignment and one point of extra credit per assignment (only on the final submission, not on the checkpoints). You may switch languages between PA2 and PA3, but I don’t recommend doing so. You must not switch between PA3 and PA4, because PA4 builds on PA3—I expect you to modify you PA3 implementation to complete PA4. See the assignment pages for more details. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/languages/#language-choice-for-programming-assignments",
    "relUrl": "/languages/#language-choice-for-programming-assignments"
  },"33": {
    "doc": "Supported Languages",
    "title": "Source and Target Languages",
    "content": "Cool . Cool is a Classroom Object-Oriented Language — it is essentially a small subset of Java. It’s small enough to be manageable for semester projects but large enough to help you to learn all of the concepts and to write non-trivial programs. Here is a “Hello, World” program in Cool: . (* hello-world.cl *) class Main inherits IO { main() : Object { out_string(\"Hello, world.\\n\") } ; } ; . Cool Reference Manual . The Cool programming language is formally specified and defined in The Cool Reference Manual, a document that you will grow to love (or hate) over the course of this semester. Multiple versions are available: . | CRM Modern — a revised manual with improved readability, but requiring browser JavaScript | CRM Modern (One Page, HTML) - a revised manual with improved readability, but requiring browser JavaScript (one single webpage) | CRM Classic — the “old-school” manual, requiring only basic HTML and images | . Cool Reference Compiler . Different versions of the reference compiler are available for different platforms. Information on running the compiler is available in the reference manual. | Linux/x86 (64 bit) (v. 1.36) (1.36 binaries with alternate library requirements: B C D) | Linux/x86 (32 bit) (v. 1.36) | Mac OS X Apple M-Series Chips (ARM-64) (v. 1.36) | Mac OS X/x86 (Intel Chips) (v. 1.36) | Win32/x86 (v. 1.36) | . Don’t forget to run chmod a+x ./cool on Unix platforms to make these executable. We also provide a library of sample Cool programs here. Additional Cool Resources . There are a number of other Cool resources available online; this is not an exhaustive list. If you find others that are useful, contact the course staff and they can be added here. Note that these resources are provided “as-is”: the course staff can’t promise to help you with them if you’re having trouble. But, feel free to ask your classmates on the course forum! . | There is Cool syntax highlighting support for Vim. | If you like XEmacs, the Berkeley Harmonia project has a Cool mode. It offers quite a bit more than syntax highlighting, but not all of the semantic features are guaranteed to be compatible with our dialect of Cool. | The Sublime text editor supports Cool syntax highlighting. | An easy-to-script implementation of Delta Debugging is available, written by Daniel S. Wilkerson and Scott McPeak. | . x86-64 . There are many dialect and syntax options of “x86 assembly language”. This course only allows the 64-bit version supported by gcc on Linux. If your regular development machine doesn’t support this flavor of x86, you’ll need to use a virtual machine (instructions here). Note that we use the default AT&amp;T syntax. To find out if your development machine supports our flavor of x86-64 assembly language, try this: ./cool --x86 hello-world.cl gcc -no-pie -static hello-world.s ./a.out . If there were no assembler or linker errors and you saw “Hello, world.”, your system can handle our x86-64 assembly. Although we’re invoking gcc, that’s just shorthand: it’s calling as and collect2 and whatnot to assemble the .s file into an object file and link that object file into an executable. You can see the individual steps with gcc -v. A Note on Position Independent Executables . On modern Linux systems (including Ubuntu since version 17.10), gcc assumes that all assembly code should be position independent by default. The reference compiler does not produce position-independent code, though (and you are not required to produce position-independent code, either). The -no-pie and -static flags to gcc tell the assembler and linker to produce a non-position-independent executable when assembling and linking. For all assembly code in this course, you should always use these flags when assembling and linking. Useful links for assembly programming that were helpful in the construction of the reference compiler: . | Randal E. Bryant and David R. O’Hallaron’s x86-64 Machine Level Proramming | Wikibook’s X86 Assembly/GAS Syntax | Stack Overflow on Assembly Debugging with GDB | GDB’s Manual on Inspecting Registers | . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/languages/#source-and-target-languages",
    "relUrl": "/languages/#source-and-target-languages"
  },"34": {
    "doc": "Supported Languages",
    "title": "Language Choices",
    "content": "Python . Python is a high-level, general-purpose programming language. Python is dynamically typechecked and garbage-collected. It supports multiple programming paradigms, including structured (particularly procedural), object-oriented and functional programming. It is often described as a “batteries included” language due to its comprehensive standard library. NJIT students should be familiar with Python from CS 100, CS 301, and other required courses. Therefore, it is a “Bucket 1” language. This course uses Python version 3.10.12. C . C is a general-purpose systems programming language, popularized along with Unix in the 1970s and 1980s. Its design emphasizes cleanly reflecting the capabilities of CPUs of that era. C is an imperative procedural language, supporting structured programming, lexical variable scope, and recursion, with a static type system. It was designed to be compiled to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support. Despite its low-level capabilities, the language was designed to encourage cross-platform programming. A standards-compliant C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code. NJIT students should be familiar with C from their systems programming courses, including CS 288. Moreover, all computer scientists should have at least a passing familiarity with C, since it is the historical “lingua franca” for systems programming. Therefore, it is a “Bucket 1” language. This course uses the GNU Compiler Collection (“gcc”) C compiler, version 11.4.0. (More specifically, (Ubuntu 11.4.0-1ubuntu1~22.04).) . C++ . C++ is a high-level, general-purpose programming language that extends C. C++ has object-oriented, generic, and functional features, in addition to facilities for low-level memory manipulation. C++ was designed with systems programming and embedded, resource-constrained software and large systems in mind, with performance, efficiency, and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, video games, servers (e.g., e-commerce, web search, or databases), and performance-critical applications (e.g., telephone switches or space probes). NJIT students should be familiar with C++ because it is used in CS 280. Therefore, C++ is a “Bucket 1” language. This course uses the GNU Compiler Collection’s g++ compiler, version 11.4.0. (More specifically, (Ubuntu 11.4.0-1ubuntu1~22.04).) . Java . Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let programmers write once, run anywhere — meaning that compiled Java code can run on all platforms that support Java without the need to recompile. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of the underlying computer architecture. The Java runtime provides dynamic capabilities (such as reflection and runtime code modification) that are typically not available in traditional compiled languages. NJIT students should be familiar with Java from CS 113. Therefore, it is a “Bucket 1” language. This course uses javac version 11.0.24, via the OpenJDK project. Bucket Two: Languages With An Unusual Type System . Kotlin . Rust . Scala . Bucket Three: Functional Languages . Haskell . OCaml . | You don’t want to use COOL as your implementation language, anyway. It intentionally omits many convenience features of higher-level languages to simplify the compiler implementation process, but that can make it unwieldy for writing “real” programs. &#8617; . | . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/languages/#language-choices",
    "relUrl": "/languages/#language-choices"
  },"35": {
    "doc": "Supported Languages",
    "title": "Supported Languages",
    "content": "This page discusses the languages supported in this class. It has two goals: . | explain the course policies on language choice for the programming assignments, and | give technical details on the versions of each language that the course supports. | . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/languages/",
    "relUrl": "/languages/"
  },"36": {
    "doc": "PA1: Rosetta Stone",
    "title": "Specification",
    "content": "Your program must take in a list of dependent tasks and either output a valid order in which to perform them or the single word cycle. Your program will accept a number of lines of textual input (via standard input). There are no command-line arguments — you must always read from standard input. Do not open a named file. Instead, always read from standard input. That text input will contain a non-zero but even number of lines. Every two lines represent a pair of tasks. The first line gives the name of a task, the second line gives the name of a task that it depends on. This text input is also called the task list. The task list will contain only standard ASCII characters (no UTF/8 Unicode or special accents). The goal is to test programming and program language concepts, not your internationalization abilities. Each task name starts at the beginning of the line and extends all the way up to (but not including) the end of that line. So the newline or carriage return characters \\r or \\n are not part of the task name. Each task name is at most 60 characters long. (This limit is to make any C implementation easier. Most languages support longer strings natively, and can thus ignore this length limit.) . Example task list: . learn C read the C tutorial do PA1 learn C . The interpretation is that in order to learn C one must first read the C tutorial and that in order to do PA1 one must first learn C. Desired output for this example: . read the C tutorial learn C do PA1 . If the task list containts a cycle of any size, your program should output exactly and only the word cycle. Example cyclic input: . get a job have experience have experience work on a job work on a job get a job . Even if the task list contains a few non-cyclic parts, any single cycle forces you to output only the word cycle. Always output to standard output only. Do not write anything to stderr. There is no fixed limit on the number of lines in the task list (although it is not zero and it is even). Two tasks with the same name are really just the same task. Use standard string equality. Duplicated pairs of tasks are not allowed. For example: . learn C read the C tutorial do PA1 learn C learn C read the C tutorial . … that task list is not valid input because the pair learn C/read the C tutorial appears twice. Program behavior if the task list contains a duplicate pair is undefined. You will not be tested on it. Your program may not cause any other file I/O to be performed, such as creating a temporary file to keep track of some intermediate sorting results or writing to stderr (or even causing the interpreter to write a warning to stderr). You do not need any such temporary files or stderr-printing to solve this problem. Choosing Among Unconstrained Tasks . If there are multiple outstanding unconstrained tasks, your program should output them in ascending ASCII alphabetical order. That is, if you ever have two or more tasks, each of which has no remaining dependencies, output the one that comes first ASCII-alphabetically. (This constraint makes your program deterministic; for any given input there is only one correct output.) Example: . learn C understand C pointers learn C read the C tutorial do PA1 learn C . Because r comes before u, your output should be: . read the C tutorial understand C pointers learn C do PA1 . To put it another way, consider this task list: . B A C D C E . Which yields a dependency graph like this: . A D E | \\ / B C . The proper ordering for this set of tasks is A B D E C. Note that B comes before D and E, even though B depends on A. This is because, once A is finished, B is free to go and it comes first alphabetically. You may want to consider this requirement when you pick your sorting algorithm. Given this requirement the answer A D E B C is incorrect and will receive no credit. Resources . Some resources are available to help you: . | pa1-hint.zip provides concrete implementations of “task list reversal” (a similar, but simpler, problem) in a wide collection of languages, including many of those in our buckets. You might use this resource to compare how to accomplish various tasks in different languages. | pa1-testcases.zip includes a number of test inputs and expected outputs so that you can test your programs before submitting. | pa1-testcases-unix.zip as above, but with unix linefeed formatting in all text files for use in Mac OS X, Ubuntu, or another Linux. | . Commentary . This problem is just topological sort not-so-cleverly disguised. Feel free to look up how to do toposort on the internet (but remember that you must turn in your own work; you may not copy someone else’s code and claim it as your own). Take a look at the files in pa1-hint.zip. You could do worse than using them as starting points. If you’re having trouble writing anything reasonable in Cool, don’t forget to look at the other example Cool programs. Building and maintaining an explicit graph structure is probably overkill. Video Guides . This assignment is a mildly-modified version of Wes Weimer’s similar assignment (the only differences are in language choices). Wes has kindly prepared a number of video guides to help students get started in various languages: . | Python | OCaml | COOL (object-oriented style, long) | COOL (imperative style, short) | . Reminder: You can watch YouTube videos at 1.5x speed with full audio. Checkpoints . This assignment has two checkpoints before the final due date. At the first checkpoint, you must turn in your Bucket 1 implementation. At the second checkpoint, you must turn in any one implementation from a bucket other than Bucket 1. At the final due date, you need to turn in all four implementations. This structure is designed to encourage you to steadily work on the assignment, rather than trying to do all four implementations in a rush at the end. It also separates the task into three stages, each with a different challenge: (1) before the first checkpoint, the challenge is Can I write this program at all?, even in a familiar language; (2) between the first and second checkpoint, the challenge is Can I write this program in some other language?; (3) after the second checkpoint, the challenge is Can I write this program in multiple unfamiliar languages?. Note that although the checkpoints get progressively more difficult, the time alloted to them is about the same. That’s because I expect you to become very comfortable with this program by the time you’re working on your fourth implementation. The schedule for the checkpoints is: . | PA1c1: due Monday, January 27 AoE. Note that this is the the drop date. If you are struggling to finish PA1c1 in time, you should consider dropping the class: the workload is likely too high for you to handle this semester. | PA1c2: due Thursday, January 30 AoE. | full PA1: due Monday, February 3 AoE. | . Note the “AoE” timezone means “Anywhere on Earth”. This means that you can submit that part of the assignment as long as it is the given date somewhere on the planet. Currently, the last place where each day ends on Earth is the Howland and Baker Islands. This transition happens at about 7am eastern time the next day (but this can vary with daylight savings time!). I use AoE for due dates because I won’t actually start grading until the next day: if you want to stay up all night doing the assignment, that’s your business. It also means that when I say that an assignment is due on a particular date (e.g., “PA1 is due on February 3rd”), you unambiguously know what I mean. What To Turn In For PA1c1 . For PA1c1, turn in any one of the following files: . | rosetta.py (Python) | rosetta.c (C) | rosetta.cpp (C++) | Rosetta.java (Java) | . We will use the file extension to determine which language you are using. See the languages page for information about the versions of each language that the grading server supports. What To Turn In For PA1c2 . Submit any one of the following files: . | rosetta.kt (Kotlin) | rosetta.rs (Rust) | Rosetta.scala (Scala) | rosetta.hs (Haskell) | rosetta.ml (OCaml) | rosetta.cl (COOL) | . What To Turn In For PA1 . Turn in six files: . | any one of rosetta.py, rosetta.c, rosetta.cpp, or Rosetta.java | any one of rosetta.kt, rosetta.rs, or Rosetta.scala | either rosetta.hs or rosetta.ml | rosetta.cl | testcase.list, which should contain a valid novel task list (it may or may not contain a cycle — your choice). Novel in this context means “different from the test cases distributed with the assignment in some meaningful way that you will identify in your README.txt. | README.txt, a plain ASCII text file (not a Word file, not an RTF file, not an HTML file) describing your design decisions. Which language did you start with? How did you store the (implicit) graph? Which language was the hardest? Why is your test case novel? One or two English paragraphs should suffice. Spelling, grammar, capitalization and punctuation all count. | . Grading Rubric . PA1 Grading (out of 25 points): . | 20 points — autograding . | 5 points — autograder tests for PA1c1 | 5 points - autograder tests for PA1c2 | 10 points — autograder tests for PA1 | The scoring is proportional: if there are 8 tests for PA1c1 and your best submission passes 4 of them (50%), you will receive 2.5/5 points for PA1c1 (50%). | . | 4 points — for a clear description in your README.txt . | 4 — thorough discussion of design decisions (including language comparisons) and choice of test cases; a few paragraphs of coherent English sentences should be fine | 2 — vague or hard to understand; omits important details | 0 — little to no effort, or submitted an RTF/DOC/PDF file instead of plain TXT | . | 1 point — for a valid testcase.list file | . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/projects/pa1.html#specification",
    "relUrl": "/projects/pa1.html#specification"
  },"37": {
    "doc": "PA1: Rosetta Stone",
    "title": "PA1: Rosetta Stone",
    "content": "The Rosetta Stone aided linguistic understanding by providing the same text in three different languages. In this project you will implement the same simple program in four separate languages. Each of your implementations will have exactly the same interface, will otherwise adhere to the same specification, and should behave exactly the same way. You must choose one language from each of the following buckets for your four implementations: . | Bucket 1: Languages You Already Know: Java, C, C++, or Python3 | Bucket 2: Languages With An Unusual Type System: Kotlin, Rust, or Scala | Bucket 3: Functional Languages: OCaml or Haskell | Bucket 4: Project Language: Classroom Object-Oriented Language (COOL) | . Each bucket is intended to challenge you in a different way. Bucket 1 gives you a chance to implement the solution in a language you’re already comfortable in, so that you can focus on the problem. Bucket 2 challenges you to redo that implementation in a language that shares some similarities with languages that you’ve seen before, but which also includes some features you might be unfamiliar with. In particular, all Bucket 2 languages support programming in a structured imperative style, even if they permit functional programming. Bucket 3 challenges you to redo the implementation in a true functional programming language. Finally, Bucket 4 will familiarize you with the course project language COOL (“Classroom Object-Oriented Language”). All subsequent assignments in this course (PA2-PA4) involve implementing parts of a COOL compiler, so you’ll have an easier time with them if you’ve used the language a bit. COOL itself is also a bit tricky to program in: it intentionally omits many convenience features of higher-level languages to simplify the compiler implementation process, but that can make it unwieldy for writing “real” programs. For this assignment, you must work alone. Subsequent assignments will allow you (optionally) to work in pairs. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/projects/pa1.html",
    "relUrl": "/projects/pa1.html"
  },"38": {
    "doc": "PA2: Semantic Analyzer",
    "title": "PA2: Semantic Analyzer",
    "content": "You may complete this assignment in any language listed on the languages page in buckets 1, 2, or 3. You may work in a team of two people for this assignment. You may work in a team for any or all subsequent programming assignments. You do not need to keep the same teammate between this assignment and subsequent assignments. The course staff are not responsible for finding you a willing teammate. You are permitted to work alone, if you choose. Goal . For this assignment you will write a semantic analyzer. Among other things, this involves traversing the abstract syntax tree and the class hierarchy. You will reject all Cool programs that do not comply with the Cool type system. You will also write additional code to unserialize the AST produced by the provided parser and to serialize the class map, implementation map, parent map, and annotated AST produced by your semantic analysis. Specification . You must create three artifacts: . | A program that takes a single command-line argument (e.g., file.cl-ast). That argument will be an ASCII text Cool abstract syntax tree file (as described below in the section “The .cl-ast File Format”). Your program must either indicate that there is an error in the input (e.g., a type error) or emit file.cl-type, a serialized Cool abstract syntax tree, class map, implementation map, and parent map. If your program is called checker, invoking checker file.cl-ast should yield the same output as cool --type file.cl. Your program will consist of a number of files in the language of your choice. The main entry point for your program must be in a file called main.$EXT, where $EXT is replaced by the customary file extension used by your programming language of choice (e.g., main.ml for OCaml, or main.c for C). If you are using a language that typically capitalizes file names (like Java), you should follow that convention as you normally would (so, a Java implementation’s entrypoint should be in Main.java). Your program cannot rely on non-standard external dependencies, and must build using your language’s standard compiler command. See the language page’s entry for your language for more details. | A plain ASCII text file called readme.txt describing your design decisions and choice of test cases. See the grading rubric. A few paragraphs should suffice. | Testcases good.cl, bad1.cl, bad2.cl and bad3.cl. The first should pass the semantic analysis stage. The remaining three should yield semantic analysis errors. | . The .cl-ast File Format . The input to your program will be in the .cl-ast format described in this section. The cool reference compiler produces .cl-ast files from .cl files; you should use it to do so when testing. You may assume that your program only receives well-formed .cl-ast files. If you want to see examples of the format, use the --parse flag of reference compiler to generate .cl-ast files. If you are having trouble reading in .cl-ast files, you are almost certainly doing something wrong: the format is designed to be easy to parse (it may require a bit of work to cover all cases, but the code you write should be pretty formulaic). Check with the TAs if you’re finding it difficult for any reason—the usual case is a misunderstanding of the specification, which is easy to clear up by explaining the trouble to the TA. The general format of a .cl-ast file follows the Cool Reference Manual Syntax chart. Basically, we do a pre-order traversal of the abstract syntax tree, writing down every node as we come to it. We now describe exactly what the parser outputs for each kind of node. You can view this as specifying a set of mutually-recursive tree-walking functions. The notation “superclass:identifier” means “output the superclass using the rule (below) for outputting an identifier”. The notation “\\n” means “output a newline”. | To Output An AST. A Cool AST is a list of classes. Output the list of classes. | To Output A List (of classes, or features, or whatever). Output the number of elements, then a newline, then output each list element in turn. | To Output A Class. Output the class name as an identifier. Then output either: . | no_inherits \\n | inherits \\n superclass:identifier Then output the list of features. | . | To Output An Identifier. Output the source-file line number, then a newline, then the identifier string, then a newline. | To Output A Feature. Output the name of the feature and then a newline and then any subparts, as given below: . | attribute_no_init \\n name:identifier type:identifier | attribute_init \\n name:identifier type:identifier init:exp | method \\n name:identifier formals-list \\n type:identifier body:exp | . | To Output A Formal. Output the name as an identifier on line and then the type as an identifier on a line. | To Output An Expression. Output the line number of the expression and then a newline. Output the name of the expression and then a newline and then any subparts, as given below: . | assign \\n var:identifier rhs:exp | dynamic_dispatch \\n e:exp method:identifier args:exp-list | static_dispatch \\n e:exp type:identifier method:identifier args:exp-list | self_dispatch \\n method:identifier args:exp-list | if \\n predicate:exp then:exp else:exp | while \\n predicate:exp body:exp | block \\n body:exp-list | new \\n class:identifier | isvoid \\n e:exp | plus \\n x:exp y:exp | minus \\n x:exp y:exp | times \\n x:exp y:exp | divide \\n x:exp y:exp | lt \\n x:exp y:exp | le \\n x:exp y:exp | eq \\n x:exp y:exp | not \\n x:exp | negate \\n x:exp | integer \\n the_integer_constant \\n | string \\n the_string_constant \\n | _identifier_ \\n variable:identifier &lt;p style=\"color:red;\"&gt;(note that this is not the same as the integer and string cases above)&lt;/p&gt; | true \\n | false \\n | . | To Output A let Expression. (Output the line number, as usual.) Output let \\n. Then output the binding list. To output a binding, do either: . | let_binding_no_init \\n variable:identifier type:identifier | let_binding_init \\n variable:identifier type:identifier value:exp Finally, output the expression that is the body of the let. | . | To Output A case Expression. (Output the line number, as usual.) Output case \\n. Then output the case expression. Then output the case-elements list. To output a case-element, output the variable as an identifier, then the type as an identifier, then the case-element-body as an exp. | . Example input .cl file: . (* Line 01 *) (* Line 02 *) (* Line 03 *) class List { (* Line 04 *) -- Define operations on lists. (* Line 05 *) (* Line 06 *) cons(i : Int) : List { (* Line 07 *) (new Cons).init(i, self) (* Line 08 *) }; (* Line 09 *) (* Line 10 *) }; . Corresponding .cl-ast file, with comments (will not be present in the output of the reference compiler): . fier 6 -- line number of return type identifier List -- return type identifier 7 -- line number of body expression dynamic_dispatch -- kind of body expression 7 -- line number of dispatch receiver expression new -- kind of dispatch receiver expression 7 -- line number of new-class identifier Cons -- new-class identifier 7 -- line number of dispatch method identifier init -- dispatch method identifier 2 -- number of arguments in dispatch 7 -- line number of first argument expression identifier -- kind of first argument expression 7 -- line number of the identifier i -- what is the identifier? 7 -- line number of second argument expression identifier -- kind of second argument expression 7 -- line number of the identifier self -- what is the identifier? . Error Reporting . To report an error, write the string: . ERROR: $line_number: Type-Check: $message . to standard output and terminate the program. You may write whatever you want in the message, but it should be fairly indicative. Example erroneous input: . class Main inherits IO { main() : Object { out_string(\"Hello, world.\\n\" + 16777216) -- adding string + int !? } ; } ; . Example error report output: . ERROR: 3: Type-Check: arithmetic on String Int instead of Ints . Line Number Error Reporting . The typing rules do not directly specify the line numbers on which errors are to be reported. The Cool reference compiler uses these guidelines (possibly surprising ones are italicized), which you should also follow: . | Errors related to parameter-less method main in class Main: always line 0 | Inheritance cycle: always line 0 | Other inheritance type problem: inherited type identifier location | self or SELF_TYPE used in wrong place: self (resp. SELF_TYPE) identifier (resp. type) location | Redefining a feature: (second) feature location | Redefining a formal or class: (second) identifier location | Other attribute problems: attribute location | Redefining a method and changing types: (second) type location | Other problems with redefining a method: method location | Method body type does not conform: method name identifier location | Attribute initializer does not conform: attribute name identifier location | Errors with types of arguments to relational/arithmetic operations: location of relational/arithmetic operation expression | Errors with types of while / if subexpression(s): location of (enclosing) while or if expression (not the location of the conditional expression) | Errors with case expression (e.g., lub): location of case expression | Errors with conformance in let: location of let expression (not location of initializer) | Errors in blocks: location of (beginning of) block expression | Errors in actual arguments: location of method invocation expression (not the location of any particular actual argument) | Assignment does not conform: assignment expression location (not right-hand-side location) | Unknown identifier: location of identifier | Unknown method: location of method name identifier | Unknown type: location of type | . Remember that you do not have to match the English prose of the reference compiler’s error messages at all. You just have to get the line number right. Semantic checks are unordered — if a program contains two or more errors, you may indicate whichever you like. (All of our test cases for grading will contain at most one error so this will not be an issue.) . The .cl-type File Format . If there are no errors in file.cl-ast your program should create file.cl-type and serialize the class map, implementation map, parent map, and annotated AST to it. The class and implementation maps are described in the Cool Reference Manual. A .cl-type file consists of four sections: . | The class map. | The implementation map. | The parent map. | The annotated AST. | . Simply output the four sections in order, one after the other. We will now describe exactly what to output for the class and implementation maps. The general idea and notation (one string per line, recursive descent) are the same as in the .cl-ast file format, described above. The Class Map . | Output class_map\\n. | Output the number of classes and then \\n. | Output each class in turn (in ascending alphabetical order): . | Output the name of the class and then \\n. | Output the number of attributes and then \\n. | Output each attribute in turn (in order of appearance, with inherited attributes from a superclass coming first): . | Output no_initializer \\n and then the attribute name \\n and then the type name \\n. | or Output initializer \\n and then the attribute name \\n and then the type name \\n and then the initializer expression. | . | . | . The Implementation Map . | Output implementation_map\\n. | Output the number of classes and then \\n. | Output each class in turn (in ascending alphabetical order): . | Output the name of the class and then \\n. | Output the number of methods for that class and then \\n. | Output each method in turn (in order of appearance, with inherited or overridden methods from a superclass coming first; internal methods are defined to appear in ascending alphabetical order): . | Output the method name and then \\n. | Output the number of formals and then \\n. | Output each formal’s name only: . | Output the name and then \\n | . | If this method is inherited from a parent class and not overriden, output the name of the ultimate parent class that defined the method body expression and then \\n. Otherwise, output the name of the current class and then \\n. | Output the method body expression. | . | . | . The Parent Map . | Output parent_map\\n | Output the number of parent-child inheritance relations and then \\n. This number is equal to the number of classes minus one (since Object has no parent). | Output each child class in turn (in ascending alphabetical order): . | Output the name of the child class and then \\n. | Output the name of the child class’s parent and then \\n. | . | . The Annotated AST . | With two exceptions, the annotated AST format is identical to the normal AST format described above for the .cl-ast file. | The first change involves expressions. To output an Expression: . | Output the line number of the expression and then a newline (as in the .cl-ast format). | Output the name of type associated with the expression and then a newline. For example, the expression 3+x is associated with the type Int. This is not required for any of the checkpoints for PA2, only in the final version of PA2. | Output the name of the expression and then a newline and then any subparts (as in the .cl-ast format). | . | The second change is a new kind of expression, internal, used to represent the bodies of predefined methods. Internal expressions are those that are handled by the run-time system — you might think of them as part of the standard library. You output Internal Expressions (including the type annotation, as above) as follows: . | 0 \\n type \\n internal \\n Class.method \\n The valid kinds of internal expressions (i.e., the values for Class.method) are: . | IO.in_int IO.in_string IO.out_int IO.out_string Object.abort Object.copy Object.type_name String.concat String.length String.substr They are formally defined in the Cool Reference Manual. | . | . | . Note that you must output information about all classes and methods defined in the program as well as all base classes (and their methods). Do not just print out “classes actually used” or “methods actually called” or something like that. Output all classes and methods — no optimizations or shortcuts! . Detailed .cl-type Example . Now that we’ve formally defined the output specification, we can present a worked example. Here’s the example input we will consider: . class Main inherits IO { my_attribute : Int &lt;- 5 ; main() : Object { out_string(\"Hello, world.\\n\") } ; } ; . Resulting .cl-type class map output with comments (each row represents one line of the .cl-type output; you only need to emit the left-most column): . | .cl-type class map | comment | . | class_map |   | . | 6 | number of classes | . | Bool | note: includes predefined classes | . | 0 |   | . | IO |   | . | 0 |   | . | Int |   | . | 0 |   | . | Main |   | . | 1 | Our Main has one attribute… | . | initialzier |   | . | my_attribute | …named “my_attribute”… | . | Int | …with type Int | . | 2 | initializer expression line number | . | Int | initializer expression type (see above: this is an expression annotated with a type) – do not emit these expression types for PA2c2! | . | integer | initializer expression kind | . | 5 | which integer constant is it? | . | Object |   | . | 0 |   | . | String |   | . | 0 |   | . Resulting .cl-type implementation map with comments: . | .cl-type implementation map | comment | . | implementation_map |   | . | 6 | six classes | . | Bool | first is Bool | . | 3 | - Bool has 3 methods | . | abort | - first method in Bool is abort() | . | 0 | – abort() has zero formal parameters | . | Object | – name of parent class from which Bool inherits abort() | . | 0 | – abort’s body expression starts on line 0 | . | Object | – abort’s body expression has type Object | . | internal | – abort’s body is an internal kind of expression (i.e., a system call; see above) | . | Object.abort | – extra detail on abort’s body expression | . | copy | - second of Bool’s three methods is copy() | . | 0 | – copy has 0 formal arguments | . | Object | – name of parent class from which Bool inherits copy() | . | 0 | – copy’s body expression starts on line 0 | . | SELF_TYPE | – copy’s body expression has type SELF_TYPE | . | internal | – copy’s body is an internal kind of expression (i.e., a system call; see above) | . | Object.copy | – extra detail on copy’s body expression | . | … many lines skipped … |   | . | Main | another class is Main | . | 8 | Main has 8 methods | . | … many lines skipped … |   | . | main | - one of Main’s methods is main() | . | 0 | – main has 0 formal arguments | . | Main | – the name of the class where Main.main() is defined | . | 4 | – the body expression of Main.main starts on line 4 | . | SELF_TYPE | – the body expression of Main.main has type SELF_TYPE | . | self_dispatch | – the body of Main.main() is a self_dispatch kind of expression | . | … many lines skipped … |   | . Finally, the resulting .cl-type parent map output with comments: . | .cl-type parent map | comment | . | parent_map |   | . | 5 | there are five clases with parents (Object is the sixth class) | . | Bool | Bool’s parent… | . | Object | …is Object | . | IO | IO’s parent… | . | Object | …is also Object | . | Int |   | . | Object |   | . | Main | Main’s parent… | . | IO | …is IO, rather than Object, because of the “inherits IO” on line 1 | . | String |   | . | Object |   | . Writing the rote code to output a .cl-type text file given an AST may take a bit of time but it should not be difficult; our reference implementation does it in 35 lines and cleaves closely to the structure given above. Reading in the AST is similarly straightforward; our reference implementation does it in 171 lines. Commentary . You can do basic testing as follows: . $ cool --parse file.cl $ cool --out reference --type file.cl $ my-checker file.cl-ast $ diff -b -B -E -w file.cl-type reference.cl-type . You should implement all of the typing rules in the Cool Reference Manual. There are also a number of other rules and corner cases you have to check (e.g., no class can inherit from Int, you cannot redefine a class, you cannot have an attribute named self, etc.). They are sprinkled throughout the manual. Check everything you possibly can. PA2c1 — Creating PA2 Tests . PA2c1 is a preliminary testing exercise that introduces a form of test-driven development or mutation testing into our software development process and requires you to construct a high-quality test suite. The goal of PA2c1 is to leave you with a high-quality test suite of Cool programs that you can use to evaluate your own PA2 type checker. Writing a type checker requires you to consider many corner cases when reading the formal and informal typing rules in the Cool Reference Manual. While you you can check for correct “positive” behavior by comparing your typechecker’s output to the reference compiler’s output on existing “good” Cool programs, it is comparatively harder to check for “negative” behavior (i.e., correctly reporting ill-typed Cool programs). If you fail to construct a rich test suite of syntactically-valid but semantically-invalid programs you will face a frustrating series of “you fail held-out negative test x” reports for PA2 proper, which can turn into unproductive guessing games. Because students often report that this is frustrating (even though it is, shall we say, infinitely more realistic than making all of the post-deployment tests visible in advance), the PA2c1 preliminary testing exercise provides a structured means to help you get started with the construction of a rich test suite. The course staff have produced 20 variants of the reference compiler, each with a secret intentionally-introduced defect related to type-checking. A high-quality test suite is one that reveals each introduced defect by showing a difference between the behavior of the true reference compiler and the corresponding buggy version. You desire a high-quality test suite to help you gain confidence in your own PA2 submission. For PA2c1, you must produce syntactically valid Cool programs (test cases). There are 20 separate held-out seeded type-checker bugs waiting on the grading server. For each bug, if one of your tests causes the reference and the buggy version to produce difference output (that is, either a different .cl-type file or a different error report), you win: that test has revealed that bug. For full credit your tests must reveal at least 15 of the 20 unknown defects. The secret defects that we have injected into the reference compiler correspond to common defects made by students in PA2. Thus, if you make a rich test suite for PA2c1 that reveals many defects, you can use it on your own PA2 submission to reveal and fix your own bugs! . Video Guides . This assignment is a mildly-modified version of Wes Weimer’s similar assignment. Wes has kindly prepared a number of video guides to help students get started on…: . | PA2c1 (which his course calls “PA4t”) | PA2c2 (which his course calls “PA4c”) | PA2 (full) (which his course calls “PA4”) | . (Aside: the reason that the type checker in Wes’ class is “PA4” but in this class it’s “PA2” is that Wes can’t make the assumption that students have built a lexer and parser before (as NJIT students hopefully did in CS 280). So, Wes’ course includes a “PA2: Lexer” and “PA3: Parser” before this assignment. That leaves Wes’ course with less time at the end of the course, so they build a Cool interpreter rather than a compiler—meaning that their course misses out on code generation and optimization, which in my opinion are the most interesting parts.) . What to Turn In For PA2c1 . For PA2c1 you should turn in (electronically): . | A set of up to 99 .cl files: Cool typechecker testcases. | Each testcase you submit must be syntactically valid (i.e., must pass cool --parse). | Each testcase you submit may be semantically valid or semantically invalid, your choice (i.e., it can pass or fail cool --type). | If you submit more than 99 tests, some will be ignored. | . | . Hint: because you can find “positive” bugs in your typechecker more easily (e.g., by running your typechecker on the correct Cool programs from cool-examples.zip), the PA2c1 exercise is strongly biased toward “negative” bugs (i.e., the secret buggy typecheckers usually fail to report certain semantic errors). PA2c2 — Typechecking Everything But Expressions . PA2c2 is a checkpoint for your full semantic analyzer implementation (unlike PA2c1, which only requires you to write test cases). The typechecker is a large project (and a large part of your grade), so it behooves you to start it early. PA2c2 exists so that students are motivated to have something working earlier, because we know that students are deadline-driven :) . For PA2c2 you should turn in an early version of PA2 that does the following: . | Reads in the .cl-ast file given as a command-line argument. | You do not need to use a parser generator to read in the .cl-ast file — its format was specifically chosen to make it easy to read with just some mutually-recursive procedures. It should take you (much) less than 150 lines to read in the .cl-ast file. | . | Does every bit of typechecking and semantic analysis possible without typechecking expressions. | Thus you should not annotate types in initializer expressions in the class map. | . | Prints out error messages as normal. | Outputs only the class map to .cl-type if there are no errors. | You can use the --class-map command-line argument to get the reference compiler to spit out the class map after typechecking (for comparison). | . | . Thus you should build the class hierarchy and check everything related to that. For example: . | Check to see if a class inherits from Int (etc.). | Check to see if a class inherits from an undeclared class. | Check for cycles in the class hierarchy. | Check for duplicate method or attribute definitions in the same class. | Check for a child class that redefines a parent method but changes the parameters. | Check for a missing method main in class Main. | Check for self and SELF_TYPE mistakes in classes and methods. | This list is not exhaustive – read the Cool Reference Manual carefully and find everything you might check for without typechecking expressions. | Basically, you’ll look at classes, methods and attibutes (but not method bodies). | . Question: What’s the exact list of errors I have to check for in PA2c2? . Answer 1: No such list is provided! Part of the assignment is thinking up all possible checks that do not involve expressions. Answer 2: Use the test cases you made for PA2c1. What to Turn In For PA2c2 . You must turn in these files: . | source_files — your implementation, including exactly one of the following files: . | main.c | main.py | main.cpp | Main.java | main.kt | main.rs | Main.scala | main.ml | main.hs | . | . What to Turn In For PA2 . You must turn in these files: . | source_files — your implementation, including exactly one of the following files: . | main.c | main.py | main.cpp | Main.java | main.kt | main.rs | Main.scala | main.ml | main.hs | . | readme.txt - your README file | good.cl - a novel positive test case | bad1.cl - a novel negative test case | bad2.cl - a novel negative test case | bad3.cl - a novel negative test case | . Grading Rubric . PA2 Grading (out of 100 points): . | 66 points — for autograder tests . | The scoring is directly proportional to the number of autograder tests you pass. | . | 5 points — for a correct PA2c1 submission | 5 points — for a correct PA2c2 submission | 8 points — for a clear description in your README . | 8 — thorough discussion of design decisions (e.g., handling of the class hierarchy, case and new and dispatch) and choice of test cases; a few paragraphs of coherent English sentences should be fine | 4 — vague or hard to understand; omits important details | 0 — little to no effort, or submitted an RTF/DOC/PDF file instead of plain TXT | . | 8 points — for valid and novel good.cl, bad1.cl, bad2.cl and bad3.cl files . | 8 — wide range of test cases added, stressing most Cool features and three error conditions, novel files (note: it is acceptable for these test cases to be a selection of the best ones from your PA2c1 submission: that’s what we expect) | 4 — added some tests, but the scope not sufficiently broad | 0 — little to no effort, or course files resubmitted as tests | . | 8 point — for code cleanliness . | 8 — code is mostly clean and well-commented | 4 — code is sloppy and/or poorly commented in places | 0 — little to no effort to organize and document code | . | . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/projects/pa2.html",
    "relUrl": "/projects/pa2.html"
  },"39": {
    "doc": "Programming Assignments",
    "title": "Programming Assignments",
    "content": " ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/projects/",
    "relUrl": "/projects/"
  },"40": {
    "doc": "Staff",
    "title": "Course Staff",
    "content": " ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/staff/#course-staff",
    "relUrl": "/staff/#course-staff"
  },"41": {
    "doc": "Staff",
    "title": "Instructors",
    "content": "Martin Kellogghe/him . martin.kellogg@njit.edu . Office Hours: Thursdays, 1:30-2:30pm eastern, GITC 4314; or by appointment. To schedule an appointment with me, check my calendar and add a calendar event in any open spot that works for you during regular business hours (Monday to Friday, 9:30-5:30). You must schedule meetings at least 24 hours in advance, or I will automatically decline them. In your invitation, you must, at a minimum, 1) invite me to the event, 2) add a note to the event description that mentions CS 490 and what you’d like to meet about, and 3) specify whether you would prefer the meeting to be in-person or remote. It is unprofessional to schedule a meeting with me unless you have exhausted your other options to solve the issue (for example, don’t schedule a meeting with me about a homework issue until you have attended a TA’s office hours and asked there). ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/staff/#instructors",
    "relUrl": "/staff/#instructors"
  },"42": {
    "doc": "Staff",
    "title": "Staff",
    "content": " ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/staff/",
    "relUrl": "/staff/"
  },"43": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/",
    "relUrl": "/tutorials/"
  },"44": {
    "doc": "Ubuntu Setup Guide",
    "title": "Ubuntu Setup Guide",
    "content": "This is a software engineering course. There a focus on reading code and using large systems to accomplish tasks, because real systems are large—too large for you to hold their entire specification or codebase in your head, almost certainly. In this course, you will be expected to develop and maintain programs and scripts in multiple languages using multiple tools. As a result, we want to help you prepare a suitable development environment for the assignments in this course—your local environment might work, but all the assignments are guaranteed to work in Ubuntu 22.04. This tutorial will guide you in setting up an Ubuntu 22.04 environment. This tutorial will help you create a development environment that matches the autograder environment. If you choose to deviate from the suggested x86_64 Ubuntu 22.04 environment, you may encounter corner cases that cause test cases to fail on the autograder. In some cases, the staff may direct you to set up an Ubuntu 22.04 Virtual Machine if you have not done so and are stuck on some assignments. Ultimately, it is your responsibility to read documentation and install supported tools. This tutorial is meant to help you walk through the creation of an x86_64 Ubuntu 22.04 environment. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html",
    "relUrl": "/tutorials/ubuntu.html"
  },"45": {
    "doc": "Ubuntu Setup Guide",
    "title": "Two Options — Local or Cloud",
    "content": "There are two options that this tutorial covers: . | Option 1: Local: Set up a local Ubuntu 22.04 Virtual machine on your computer. This is the most popular option for individual assignments, but the individual assignments typically work in most environments (so you probably don’t need to do this unless you run into a problem). It has a nice UI that makes it easy to navigate. | Some students may have WSL Ubuntu set up. It is a different version of Ubuntu and may or may not work for this class: we recomend that you follow the instructions below if you run into trouble. However, your experience setting it up will help you here! | Some student reports that VirtualBox is not compatible with the new Macbooks (e.g., with M1 and M2 chipsets). If you are using such a Macbook, you may have to select the Option 2 below and use the Cloud instead of your local machine. | Some students have experience with docker. Unfortunately, docker will not suffice here (but experience with it will help you): follow the instructions below. | Some students already have other versions of Ubuntu installed. Everything will probably work fine on these other versions, but again if you run into trouble you should follow these instructions. | . | Option 2: Cloud: Set up an Amazon EC2 cloud instance with Ubuntu 22.04 running on it. This option will work if you have a slower or older computer. Start early; Amazon takes up to 24 hours to verify cloud computing accounts. This option involves more of a command-line interface but typically runs some course tools a bit faster than local machine. | . Both options should work with all assignments in this course. Option 1 (local VM) will have you install VirtualBox on your computer, download an Ubuntu 22.04 installation image, and install x86_64 Ubuntu 22.04 in your virtual machine. A reasonably modern computer (e.g., at most 5 years old) should be able to run a VM guest without issue. However, some students report that the VM executes too slowly (e.g., the mouse is laggy, keystrokes are missed, programs take too long, etc.). If your VM guest is too slow, you can consider using Option 2 instead (see below). First, you may want to read the summary of virtual machines and cloud computing below. Even if you are familiar with the concepts from previous experiences, this course may use slightly different terminology, and I recommend that you skim the material (click on the box below to see the background material). Background: Virtual Machines and Cloud Computing A Virtual Machine is an emulation of a computer system. Loosely, you can think of a VM as a program that can run an entire virtual computer system. Virtual machines are powerful software systems that enable running software designed for one operating system inside another operating system. For example, you can use your Windows host computer to run a Virtual Machine that contains a Linux operating system. Consider the image below: . This is a Windows 10 host_computer running three different Virtual Machine _guests. The guest instances are complete (virtual) environments that are isolated from the host. All of the guests share the host’s hardware as they execute — each window in the screenshot above lets you interact with a separate emulated guest. Thus, even though the host is a Windows computer, you can use one of the guests to execute Linux software inside the guest. Virtual Machines can be used in many combinations. You can have a Windows, Linux, or Mac host computer, and run arbitary numbers and combinations of Linux and Windows guests. Finally, guests are stored as files in the host computer — this means you can move your VM guest from one host to another by transferring that file around. Option 1 (“Local”): You can choose to set up and run your own Ubuntu 22.04 virtual machine locally. This will allow you complete all of the assignments in this course within that virtual machine. However, some students report that the VM guest runs too slowly (especially if you do not have enough RAM in your computer). If you find that a local VM is too slow, you can use Option 2 instead. Virtual machines are a critical part of Cloud computing. You can “rent out” computing resources from a provider like Amazon EC2 or Microsoft Azure to do whatever computation you might need. Amazon EC2 and Microsoft Azure both offer you virtual machine guests that run on their hardware. Thus, you can get access to a virtual machine running whatever operating system you like to run a variety of software. Option 2 (“Cloud”): If you find that a local VM is too slow, you can instead get a free Ubuntu 22.04 virtual machine from Amazon EC2 (or any other cloud computing provider, but this specification walks you through how to do it on EC2). Amazon EC2 (“Elastic Cloud Compute”) is a service that lets you buy and configure virtual machines. Option 2 has you setup and launch an Ubuntu 22.04 cloud instance (this is free if you are a student). Many of the assignments are easier to complete on Linux or similar command-line systems. If you’re not comfortable with such systems, the background tab below on Linux Fundamentals might be useful: . Background: Linux Fundamentals Vanderbilt professor Kevin Leach has prepared a (long) video that provides a gentle introduction to a number of Linux concepts that are relevant to this course. This video is optional, but you may find it useful if you are less familiar with the Linux environment. There are timestamps in a comment below the video that contain points of interest, such as: . | terminals | environment variables | scripts in the shell | compiling programs from source | using ssh | . The first half is more about terminals and shells (why do we have to type ./a.out? why can’t we just say a.out?), and the second half is more about compiling programs from source. The video also covers elinks in particular, which is a terminal-based browser program (using elinks is not required for this course, but it might be helpful if you choose to use a cloud computer and need to access the web to e.g., submit an assignment). ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html#two-options--local-or-cloud",
    "relUrl": "/tutorials/ubuntu.html#two-options--local-or-cloud"
  },"46": {
    "doc": "Ubuntu Setup Guide",
    "title": "Option 1 — Local Virtual Machine",
    "content": "You can set up your own local virtual machine for free. However, before you proceed, consider checking whether your CPU supports accelerated virtualization. If your CPU does not support virtualization extensions, then your VM may run slowly. If that’s the case, consider Option 2 for this assignment instead. You will need: . | A copy of VirtualBox for your operating system. General download link (look under “Platform Package” or similar). | A copy of 64-bit Ubuntu 22.04 (Download — 64-bit is required here: don’t use 32-bit). This is a large .iso file that might take a long time to download. You don’t need it until part way through the installation process, but you should start the download now. | When something goes wrong during this installation, we recommend that you search this webpage and also look for previous posts on the forum. Some solutions may be listed a little lower on the webpage than when you encounter them. Macs typically give students many more issues than Windows machines, so if you are a student using a Mac, looking to see if the issue is already addressed can be a big time saver. | . VirtualBox . VirtualBox is a Virtual Machine Manager. You install VirtualBox on your host computer (i.e., as a regular program or app). Then, you use VirtualBox to create a virtual machine guest. Once you have created a guest, you install Ubuntu 22.04 inside of the guest. Then, you can start the guest and have a complete Ubuntu 22.04 environment within that guest. Isolation in Virtual Machine Guests Note well: Implicit here is that the guest is, to some extent, isolated from the host. This is very important and entails a number of conceptual hurdles if you are not used to virtualization: . | The clipboard is isolated. That is, if you copy something from your host environment, you cannot paste it inside the guest environment. This is because the VM guest is a completely independent operating system environment from your host. | Typing and mouse movements have to be captured by the guest. | If you want to download a file to use in the guest, you must do so from the guest environment. Unless you set up a shared drive (which is not required), you have to download or create files within the guest environment rather than the host environment. | . Installing VirtualBox . You can install VirtualBox with the default settings. For your reference, screenshots of the course staff completing the installation are shown below: . If you receive a “The installation failed.” message on a Mac, you can resolve the issue by going to Security and Privacy and allowing the installation. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html#option-1--local-virtual-machine",
    "relUrl": "/tutorials/ubuntu.html#option-1--local-virtual-machine"
  },"47": {
    "doc": "Ubuntu Setup Guide",
    "title": "Creating a Virtual Machine",
    "content": "After installing VirtualBox, it will display the main VM Management console, which we can use to create a New Machine (see circular highlight in upper left): . Next, configure your virtual machine. Select “Type” as “Linux” and “Version” as “Ubuntu 64-bit”. (If you only see options for 32-bit and do not see options for 64-bit, you will not be able to complete this option and will instead have to use the Amazon EC2 Cloud instance option. This happens to some students with older 32-bit Mac machines that cannot emulate 64-bit guests.) You can name your VM whatever you like (though note that the name in the picture is from a different course than this one that uses the same setup). We recommend using at least 2048MB of Memory. See highlights below: . Next, it will ask you to create a storage device. Remember, you are creating a virtual machine — an entire simulated computer. That includes simulating a hard disk for storage. This is represented as a large (&gt; 20GB file) on your host computer. We recommend at least 20GB, and you can choose “dynamically allocated” to save space: . After this step, you will have successfully created a Virtual Machine. Now, you have a bare system with nothing installed on it. Next, we must install an OS on it to run the VM. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html#creating-a-virtual-machine",
    "relUrl": "/tutorials/ubuntu.html#creating-a-virtual-machine"
  },"48": {
    "doc": "Ubuntu Setup Guide",
    "title": "Installing an OS in the Guest VM",
    "content": "After creating a VM, we need to install Ubuntu 22.04 on it to help run software. Remember downloading a large .iso file as indicated above when we discussed downloading Ubuntu (if you missed it, you should go back and download it now)? This is a Disk Image — we need to attach the OS Disk Image into the VM. On the VM Management window, right click the VM you just created, and click “Settings”: . Next, click on “Storage”, then click on the “Empty IDE Controller” (your version of VirtualBox may call this a CD drive, Optical storage drive, or similar. Regardless, you should be able to select a virtual disk image). Click the Disk icon, then click “Choose disk file…”: . Then, select the Ubuntu .iso file you downloaded earlier. This places the Ubuntu 22.04 installation medium in the VM’s disk drive. Click OK, and you are now ready to start your VM from the Manager (note: the image below is from a previous version of the course that used Ubuntu 16.04 instead of Ubuntu 22.04. When you do this, your .iso file must be for Ubuntu 22.04.): . If you receive a “Kernel driver not installed” error, follow these instructions online for how to resolve the issue. (The image below shows the “Kernel driver not installed” error, for your reference.) . The Virtual Machine will now boot and load the Ubuntu 22.04 installation. The VM opens in a new window — you can think of this window as the virtual “screen” that lets you see what’s happening in the emulated system. You can follow through the normal Ubuntu 22.04 installation: . Note: If the VM asks you to select a startup disk, you need only select your .iso file. You want the VM to boot from the installation media so you can install Ubuntu within the guest. We recommend opting to install updates and third-party software. It should not affect the system one way or another: . You can select “Erase disk and install Ubuntu”. This is only referring to erasing the “virtual” disk you created earlier with the VM. If you are receiving an error like the “following disc images couldn’t be opened for the reason of no mountable file systems”, you may be able to resolve the issue by following recommendations online . Note: Sometimes during installation, students find that a window is too large to display all the buttons. You can actually move the window like normal to reveal the Continue button (just click to drag the window like any other — the window inside the Virtual Machine, not the Virtual Machine itself): . Next, it will ask you to create an account for logging in. You can put whatever credentials you like here — it will not have any bearing on your host computer. This is merely for an account on the guest VM. Just make sure you don’t forget whatever password you choose! . Next, you just wait a bit for the OS to install inside the guest. It might take a few minutes to complete. Eventually, you’ll see a screen asking you to remove installaton media and restart. You can just click restart (on the guest) and you’ll be all set! . Virtual Machines and Mice While you’re running the VM, you may find that it “takes control” of your mouse and keyboard, and you aren’t able to leave the window. If this happens, press CTRL+ALT to release control from the VM window. (The keystrokes may be different on Mac OS). ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html#installing-an-os-in-the-guest-vm",
    "relUrl": "/tutorials/ubuntu.html#installing-an-os-in-the-guest-vm"
  },"49": {
    "doc": "Ubuntu Setup Guide",
    "title": "Install VirtualBox Additions",
    "content": "One thing you’ll notice when you install your VM successfully is that the window is small. In our opinion, one thing that makes the experience way better is the VirtualBox Additions package. It provides a number of “Quality of Life” features when using VMs. It’s essentially a helper program you install inside the VM guest that makes it “aware” that it’s running inside of a VM. To install, click “Devices”, then “Insert Guest Additions CD Image…” . Eventually, a window pops up asking if you want to run the media. Just click Run. After installing, you can reboot the VM image. One more step to make sure gcc (a compiler for C and C++ programs) is installed in your guest. In a terminal, use: . sudo apt-get update sudo apt-get install gcc . You’re all set! . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html#install-virtualbox-additions",
    "relUrl": "/tutorials/ubuntu.html#install-virtualbox-additions"
  },"50": {
    "doc": "Ubuntu Setup Guide",
    "title": "Option 2 — Amazon EC2",
    "content": "Note well: This option will take longer than Option 1. Amazon AWS accounts can take up to 24 hours to verify, which means you may have to wait before you can use it for an assignment or demo. Start early! . You will need a Secure Shell (SSH) client. SSH allows you to remotely interact with a server. (If you’ve never used SSH before, scrolling back up the page and watching the appropriate section of the “Linux Fundamentals” video might help.) When you SSH to a remote computer, you have access to a command prompt that runs software on that computer. We will be using SSH to interact with a virtual machine we create in the cloud with Amazon EC2. On Windows, I recommend using WSL to run SSH. You can also use PuTTY. On Mac, you should already have ssh installed. Open a terminal and you can run ssh. On Linux, you can use ssh, but you may need to install it first (e.g., sudo apt-get install openssh or similar, depending on your platform). It is your responsibility to understand how to use SSH, though we give some pointers below. Amazon EC2 is a cloud computing service that allows you to rent virtual machines that you can ssh to and run programs like any other computer. Amazon offers a large number of cloud-based services all under the umbrella of AWS (Amazon Web Services). EC2 is a subset of AWS. In this section, you will create an AWS account to manage EC2 virtual machines. You can sign up for a new account on Amazon EC2, and in doing so, you get 12 months of free access to a virtual machine that is enough to complete the assignments in this course. If you do not already have an Amazon EC2 account, navigate to https://aws.amazon.com/ec2/ and click “Create new account” in the upper right. Complete the sign up process. You may be prompted for credit card information, however you should not be charged as long as you create only one virtual machine on the free tier. You then will have access to the Amazon AWS Console. If you are prompted, you want to sign in as a “Root” user for the AWS console. AWS Account Creation Note that it can take 24 hours for Amazon to verify your account. We believe this is because they manually review account creation — after all, they are giving you access to computing resources. Since cloud services are easily abused (e.g., for spam emails, command and control virus management, and distributed denial of service attacks), Amazon applies a bit of scrutiny to AWS users. Start early! . Notice: AWS Web GUI Changes Some of the screenshots in this guide are from older versions of the AWS Web Interface. The GUI changes fairly frequently and so your view may look a little different from the screenshots. Everything is fine and it’s good practice to follow along with documentation that is not an exact match. The course staff verified that the instructions work and pass the HW0 autograder most recently on 8/27/2022. If you believe you’ve discovered a problematic difference between this guide and the current version of the AWS GUI, contact your TA. Creating a New VM . Now that you have created an account, you can use the AWS Console to help manage and launch virtual machine instances. We will walk you through the steps to create an Ubuntu 22.04 VM below. (1) Open the AWS Console . After you create an AWS account, you can visit the AWS Console at https://console.aws.amazon.com. At the console, you should be greeted with a large screen full of many services. See highlight on left: . Click here to see AWS Console screenshot . (2) Open the EC2 Manager . From the AWS Console, click the “EC2” link to open the Elastic Cloud Compute manager. The EC2 Manager lets you manage and launch Instances, which are virtual machines that you configure. The first thing we need to do is configure and launch a new instance. Click the Launch Instance button. Click here to see EC2 Manager screenshot . (3) Choose an Ubuntu 22.04 LTS Instance . This is the most important step. You must select an Ubuntu Server 22.04 LTS (HVM), SSD Volume Type instance. This is a free tier eligible instance that contains an environment suitable for completing the rest of the assignments. Don’t pick other versions of Ubuntu (NOT 18.04 or 20.04, etc.). The autograder uses Ubuntu 22.04 (in an AWS VM!), so if you want the smoothest experience, use that version. As of 1/12/2023, the correct image is the default for Ubuntu: . Click here to see screenshot of the instructor selecting the correct VM image . After that you can fill out the rest of the selection (e.g., making certain to select your key pair for that instance) and then verify that it is in the Free Tier. Click here for \"free tier\" screenshot . (4) Configure Your Instance . After you select the image to launch, it may ask you a few questions about storage (pick the default if so). Usually, it will skip ahead and ask you about instance details. You want to pick the free version, called a t2.micro instance. If you were using cloud computing for a business or another project, you could configure resources like (a) how many CPUs, (b) how much RAM, and (c) what type of storage you get on the VM. For this course, just pick “t2.micro” to get the free level. Click here for instance type selection screenshot . (5) Configure Authentication . After you set up your instance, you need to create a way to login. This is a tricky security problem because Amazon wants to give you root (Administrator) access to your new instance. The way they do this is by using asymmetric key encryption. Basically, Amazon will let you download a file that serves as your credentials. Rather than entering a password, you will provide this special file to let you login. If you’d like to learn more about asymmetric key encryption, take a security course. Now, you will be prompted to set up credentials for logging in. Select Create a new key pair and type in any name (the examples use “eecs481” in the screenshots below). (If you are given a key type option, like “RSA” vs. “ED22519”, pick “RSA”.) Then, click Download Key Pair. It is imperative that you keep this file in a secure location. Do not upload it to GitHub, do not move it around. This is basically like a password for accessing your instance — you wouldn’t want someone malicious to access your instance and do something bad with it (you would be legally responsible for whatever they did!). Click here for keypair creation screenshot . Once you had downloaded your Key Pair, you should be able to Launch your instance. Do so and continue. There is a screenshot below showing what you should see after launching your instance. Click here for launch confirmation screenshot . (6) Connect to Your Instance . At this point, you have set up an Ubuntu 22.04 instance on EC2 and created associated credentials. You now have a virtual machine running in the cloud that you can connect to. You will use ssh to connect to your instance. This is the recommended way — you could technically install a front-end and use remote desktop software, however we strongly recommend using the command line, since you will be using the CLI in many of the course assignments. From the EC2 Management Dashboard, right-click your running instance. You should see a menu pop up like below: . Click “Connect”. It will pop up a window giving you a number of options. Pick the “SSH Client” tab to see how to connect via ssh: . On this window, you will see the hostname of your EC2 instance to which you can ssh, as well as a number of instructions for connecting. Mac permissions errors Some students, especially those using Mac computers, report receiving permission errors when they try to SSH into their EC2 instances: . In this case, a command like . chmod go-rwx /path/to/eecs481.pem . usually resolves the issue. More information is available online about this SSH issue. Using Windows WSL to SSH to EC2 If you are using Windows Subsystem for Linux (WSL) to connect to your Amazon EC2 instance, you must prepare your key file before connecting. Our recommendation is to run the following (but use your path): . mkdir -p ~/.ssh/ cp /path/to/your/downloaded/eecs481.pem ~/.ssh chmod 400 ~/.ssh/eecs481.pem . Windows WSL does not apply Linux file permissions correctly unless you are dealing with files contained within the Linux FS. Moving your key to ~/.ssh/ will allow you to chmod 400 appropriately. The SSH client will not allow you to connect to any server using that key if it does not have the correct permissions. Recall you downloaded a .pem file when you set up authentication for your instance (see part 5 above). You must specify this file on your SSH client to connect to your instance. First, you must provide the correct access permissions to the .pem file. Usually, this means running chmod 400 /path/to/your/.pem. Once you do so, you can use the ssh command directly: . ssh -i /path/to/your/.pem ubuntu@&lt;your-EC2-hostname-here&gt; . (You must substitute in the path to your downloaded .pem file as well as the hostname of your EC2 instance, which takes the form of ec2-X-Y-Z.us.W.compute.amazonaws.com for some values of W, X, Y, and Z. Collect these values from the EC2 Console.) . If you receive an error that the path is “too long for Unix domain socket” or the like, open ~/.ssh/config in a text editor and modify the control path to match this (reference): . Host * ControlPath ~/.ssh/control/%C ControlMaster auto . At this point, you should be logged in to your EC2 Instance! See below for an example of connecting to such an instance from the WSL environment (though note that the machine in the screenshot uses an old version of Ubuntu. Your instance should be version 22.04 (codename: jammy) instead of version 16.04): . Once you’re all finished, you need one more step to install gcc (a compiler for C and C++ programs): . sudo apt-get update sudo apt-get install gcc . You can safely stop the VM instance when you aren’t using it (e.g., between homeworks) and restart it when you are. ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html#option-2--amazon-ec2",
    "relUrl": "/tutorials/ubuntu.html#option-2--amazon-ec2"
  },"51": {
    "doc": "Ubuntu Setup Guide",
    "title": "Final Remarks",
    "content": "There is a lot of systems programming in this course. We will use a mixture of command line tools, multiple languages, and other large projects that you may not have seen, written, or used before. That’s the point. In software engineering, much of your day-to-day work will involve reading code and documentation, as well as getting things set up to run. We are big believers that this type of experience is some of the most valuable you can acquire as a student — it makes you more productive at other tasks. This tutorial is not meant to take more than 2 hours (excluding the time taken to download the Ubuntu 22.04 .iso in Option 1, or the Amazon AWS signup time in Option 2). Please contact us on Discord if you have any questions! . ",
    "url": "/martinjkellogg.com/teaching/cs485-sp25/tutorials/ubuntu.html#final-remarks",
    "relUrl": "/tutorials/ubuntu.html#final-remarks"
  }
}
