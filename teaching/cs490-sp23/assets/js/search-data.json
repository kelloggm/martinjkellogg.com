{"0": {
    "doc": "CS 490 (Sp23)",
    "title": "Welcome to CS 490!",
    "content": "Welcome to CS 490: Guided Design in Software Engineering! This is a course about building software that satisfies stronger properties than “it works”: it’s about building software that is correct, reliable, maintainable, testable, and usable. That is, this course will teach you about how to build software well. The course is structured around giving you experience in both the theory (through readings and lectures) and the practice (through programming assignments and a large group project) of software engineering. On this course website, you can find: . | the syllabus, | announcements, | a course calendar (which includes links to the required readings)), | a staff page, | links to all assignments, | useful tutorials, | and a weekly schedule. | . ",
    "url": "/~mjk76/teaching/cs490-sp23/#welcome-to-cs-490",
    "relUrl": "/#welcome-to-cs-490"
  },"1": {
    "doc": "CS 490 (Sp23)",
    "title": "CS 490 (Sp23)",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/",
    "relUrl": "/"
  },"2": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": "Welcome to CS 490: Guided Design in Software Engineering! This is a course about building software that satisfies stronger properties than “it works”: it’s about building software that is correct, reliable, maintainable, testable, and usable. That is, this course will teach you about how to build software well. The course is structured around giving you experience in both the theory (through readings and lectures) and the practice (through programming assignments and a large group project) of software engineering. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/",
    "relUrl": "/about/"
  },"3": {
    "doc": "Syllabus",
    "title": "Course Outcomes",
    "content": "Official course outcomes: . | Students will be able to explain the major theories and methods applicable to professional software engineering. | Students will be able to design, implement and evaluate a computer based system to meet desired needs. | Students will be able to function effectively on a team to accomplish a goal. | Students will be able to use current techniques, skills and tools necessary for computing practice. | . My course design is based additionally on these unofficial outcomes: . | Students will be able to assess the quality of software engineering being done at some future workplace | Students will be competent software engineers that I wouldn’t be worried about hiring | . ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#course-outcomes",
    "relUrl": "/about/#course-outcomes"
  },"4": {
    "doc": "Syllabus",
    "title": "Prerequisites",
    "content": "Technically this course requires CS 280 and CS 288, which are both courses about how to program. I will assume in this course that you know how to program: that is, that if I tell you to go write some code, you’ll be able to go do it. Since this course focuses on how to program well (i.e., how to engineer software!), you first need to know how to program at all. I’ll also assume some familiarity with command line tools, debugging, and using a search engine: I expect that if I ask you to go write code in some language you’ve never seen before, you’ll be able to find the necessary components online, find an online tutorial on the syntax, and figure out how to write that code. Put another way, I won’t teach you how to write a program: this course already assumes that you can do that. As an analogy to carpentry, classes like CS 113 teach you how to build the equivalent of a software cabinet. CS 280 and CS 288 teach you how to build something like a software shed: pretty big, but still small enough for one person to do on their own by combining the skills they learned building cabinets. CS 490 is about the equivalent of building a software high-rise: not only is it more than a single-person job, but also there’s lots of other things you need to worry about that don’t come up when you’re building a shed. The first homework assignment is due immediately before the drop date, and is intended to let you check that you have the basic skills that will be needed for this course: it requires you to write a well-defined program in a language you’ve never seen before. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#prerequisites",
    "relUrl": "/about/#prerequisites"
  },"5": {
    "doc": "Syllabus",
    "title": "Topics",
    "content": ". | What is Software Engineering? | Software Engineering process | Version control | Code review | Programming in teams | Testing, including coverage, continuous integration, test-driven development, mutation testing, and fuzzing | Requirements and specifications | Programming languages | Build systems | Static analysis | Debugging | Architecture and design, including design patterns, microservice design, designing for security, and designing for scale | Technical debt, refactoring, and maintenance | DevOps, logging and post-mortems | Open source software | . ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#topics",
    "relUrl": "/about/#topics"
  },"6": {
    "doc": "Syllabus",
    "title": "Grading and Assignments",
    "content": "Your grade is composed of the following sub-scores (in no particular order): . | 15%: Participation &amp; Professionalism | 5%: Optional Reading Responses | 15%: Individual Projects | 45%: Group Project | 20%: Final Exam | . This class will be curved: when grading, I prefer to use the whole range available rather than scores in a tight range. That is, if an assignment is worth 10 points, I will give grades at all the points between 0 and 10. I will project your raw scores onto the final distribution three times during the semester: . | after the first optional reading is graded (~ halfway through the class) | shortly before the final exam | when I compute final grades. | . You will be notified of your current projected class grade via email at each of these points. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#grading-and-assignments",
    "relUrl": "/about/#grading-and-assignments"
  },"7": {
    "doc": "Syllabus",
    "title": "Readings and Reading Responses",
    "content": "Each lecture has two kinds of readings: mandatory and optional readings. I expect you to read mandatory readings before coming to class that day, and participation quizzes (see Participation &amp; Professionalism, below) will cover the mandatory readings only. During the semester, you must complete at least two optional readings and do an associated task. Most optional readings are research papers from the software engineering literature: the idea is that you will do a deeper dive on two topics that interest you. Some optional readings have a specific task associated with them; if you choose one of those, complete the task and then submit the result on Canvas. If there is no task associated with an optional reading, the task is to write a one-page reaction to the paper that explains what you have learned and submit that to Canvas. There is no required format for your reaction, but you might consider including any or all of the following: . | a one or two paragraph summary of the key points of the paper | a list of the paper’s strengths: what did the paper do well, scientifically? | a list of the paper’s weaknesses: what did the paper do poorly? Did it makes claims you didn’t believe? | a description of how this paper might be useful to a software engineer working in industry | a description of how you might apply a lesson from the paper to your own work, now or in the future | . When you submit an optional reading task, be sure to include in your submission the title of the optional reading. One optional reading is due ~50% of the way through class (in spring semesters, around spring break). The other is due at the end of the semester. For the first optional reading, you aren’t restricted to readings that are associated with lectures earlier in the semester: you are always welcome to read ahead. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#readings-and-reading-responses",
    "relUrl": "/about/#readings-and-reading-responses"
  },"8": {
    "doc": "Syllabus",
    "title": "Participation &amp; Professionalism",
    "content": "Your participation &amp; professionalism grade is composed of two scores. First, your Professionalism score is based on the instructor’s impression of how well you participated in class, with deductions for distracting other students and credit for asking and answering questions (either in person or on the course discussion board). Second, your Participation score is based on reading quizzes (about topics from the mandatory readings only - quizzes will never cover optional readings) at the beginning of most lectures. You get half credit on these quizzes just for being there, and half credit for answering the reading questions correctly (the questions will always be easy if you did the reading). For full participation, you need to get at least a score of 60% on all quizzes over the whole semester (this gives you space to e.g., miss a reading quiz because you were sick or have a family emergency - there are no excuses for missing reading quizzes). Put another way, you can miss up to 40% of the reading quiz points and still get full participation points. These policies are designed to encourage you to come to class. A big part of the goal of this class is to help you develop an intuition for what good software engineering looks like, and without coming to class you won’t get the full benefit of that intuition. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#participation--professionalism",
    "relUrl": "/about/#participation--professionalism"
  },"9": {
    "doc": "Syllabus",
    "title": "Course Project (both Individual and Group)",
    "content": "The assignments and project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement a new feature. The codebase that we’ll be developing on is a remote collaboration tool called Covey.Town. Covey.Town provides a virtual meeting space where different groups of people can have simultaneous video calls, allowing participants to drift between different conversations, just like in real life. Covey.Town is inspired by existing products like Gather.Town, Sococo, and Gatherly.IO — but it is an open source effort, and the features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. At the end of the semester, the instructors and TAs will evaluate all of the student projects, and select the best (in terms of usability, code quality, test suite quality, and overall design) to merge into the open source Covey.Town codebase on GitHub repository. No additional course credit will be awarded to these teams, but these students will have the opportunity to receive public recognition for their project (in the form of a pull request merged into our repository and acknowledgements in the project’s contributors list). The project will provide hands-on experience to complement the skills taught in this class, requiring students to be able to: . | Work effectively in a small team | Enumerate and prioritize development tasks | Propose, design, implement and test a new feature in an existing non-toy software application | Write code that their team members can read and review | Review teammates’ code | Analyze a proposed software architecture | Use relevant software tools, such as: . | TypeScript | Visual Studio Code (or similar IDE) | Git | Mocha and Jest | Twilio’s Programmable Video API | Postman | . | . ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#course-project-both-individual-and-group",
    "relUrl": "/about/#course-project-both-individual-and-group"
  },"10": {
    "doc": "Syllabus",
    "title": "Final Exam",
    "content": "The final exam will be held during the last regular class meeting of the semester. It will cover a range of topics discussed in lecture and/or in the mandatory readings, from any time during the semester. The exam will be comprehensive, covering many of the topics we discuss; I may ask about anything we covered in class or that you were supposed to read. The exam will be conducted in person. Contact the course staff privately via email if you are not able to attend for any reason (e.g., you are sick) and we will arrange an alternative. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#final-exam",
    "relUrl": "/about/#final-exam"
  },"11": {
    "doc": "Syllabus",
    "title": "Collaboration Policy",
    "content": "Collaboration is generally encouraged in this course, as is consulting online resources. You are permitted to copy small amounts of code from any source except another student’s copy of an assignment, as long as you cite your source. “Another student’s copy of an assignment” also includes students not currently enrolled in the course - e.g., students who took this class in previous semesters or took classes that used similar individual projects at other institutions. To make this more clear, here are some examples of acceptable and unacceptable collaboration on a programming assignment in this course: . Acceptable collaborations: . | Discuss problems/solutions/anything with any number of other students (as long as you don’t look at each other’s code) | Copy a short (about 10 lines or fewer - use your judgment) snippet from stackoverflow.com or a similar source, as long as you include a comment with the source URL. | Copy code written by one of your teammates during the group project for another part of the group project. | . Unacceptable collaborations: . | Copy code directly from another student on an individual project. | Copy code from another group on a group project. | Copy a significant portion (more than about 10 lines of code - use your judgment) of your assignment from the internet, even if you cite your source. | Copy a short snippet from the internet without citing your source. | . These rules are intended to mimic what is acceptable in industry when working as a software engineer: using the resources available to you, such as your teammates and the wider internet, is always allowed. But, it would be illegal to copy code from a competing company working on a similar product. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#collaboration-policy",
    "relUrl": "/about/#collaboration-policy"
  },"12": {
    "doc": "Syllabus",
    "title": "Consquences of Violating the Collaboration Policy",
    "content": "(From the University) . “Academic Integrity is the cornerstone of higher education and is central to the ideals of this course and the university. Cheating is strictly prohibited and devalues the degree that you are working on. As a member of the NJIT community, it is your responsibility to protect your educational investment by knowing and following the academic code of integrity policy that is found at: http://www5.njit.edu/policies/sites/policies/files/academic-integrity-code.pdf. Please note that it is my professional obligation and responsibility to report any academic misconduct to the Dean of Students Office. Any student found in violation of the code by cheating, plagiarizing or using any online software inappropriately will result in disciplinary action. This may include a failing grade of F, and/or suspension or dismissal from the university. If you have any questions about the code of Academic Integrity, please contact the Dean of Students Office at dos@njit.edu” . ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#consquences-of-violating-the-collaboration-policy",
    "relUrl": "/about/#consquences-of-violating-the-collaboration-policy"
  },"13": {
    "doc": "Syllabus",
    "title": "Late Policy",
    "content": "You may use up to two late days on Individual Projects 1 and 2 (in total: either 2 on one of the two or one on each) without penalty. Assignments turned in after your second late day will not be accepted. Your group may use up to two late days on the Group Projects (in total). Assignments turned in after your group’s second late day will not be accepted. You may not use late days on Individual Project 0, the Group Project Presentation, or the Group Project Final Submission. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#late-policy",
    "relUrl": "/about/#late-policy"
  },"14": {
    "doc": "Syllabus",
    "title": "Acknowledgements",
    "content": "This course is heavily inspired by a number of other courses in software engineering at other universities, especially: . | Jon Bell’s CS 4530 at Northeastern (special thanks to Jon and his colleagues for their permission to re-use the Covey.Town project materials.) | Wes Weimer’s EECS 481 at the University of Michigan | Michael Ernst’s CSE 403 at the University of Washington | . As a student, if you’re looking for more materials (or just a different perspective) on any of the topics we cover, you might start with those (excellent) courses. ",
    "url": "/~mjk76/teaching/cs490-sp23/about/#acknowledgements",
    "relUrl": "/about/#acknowledgements"
  },"15": {
    "doc": "Announcements",
    "title": "Announcements",
    "content": "Announcements will be posted here and on CampusWire. ",
    "url": "/~mjk76/teaching/cs490-sp23/announcements/",
    "relUrl": "/announcements/"
  },"16": {
    "doc": "Announcements",
    "title": "Welcome to CS 490!",
    "content": "Jan 17 &middot; 0 min read Welcome to CS 490! This webpage is the main hub for the course. ",
    "url": "/~mjk76/teaching/cs490-sp23/announcements/",
    "relUrl": "/announcements/"
  },"17": {
    "doc": "Calendar",
    "title": "Calendar",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/",
    "relUrl": "/calendar/"
  },"18": {
    "doc": "Calendar",
    "title": "Week 1",
    "content": "Jan 17 Introduction No reading, but you should come to class (even if you’re on the waitlist) to do an in-class activity. If you’re unable to come to class (e.g., you’re sick), email me - the activity can also be completed remotely, and it’s important that everyone does it. Jan 19 Code-level Design Mandatory reading: Spolsky’s The Joel Test (note that this article is from 2000, so the examples are a little dated) and Triglia’s Why you should use Black for your Python style linting Optional reading: Ajami et al.’s Syntax, predicates, idioms — what really affects code complexity? . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-1",
    "relUrl": "/calendar/#week-1"
  },"19": {
    "doc": "Calendar",
    "title": "Week 2",
    "content": "Jan 23 Individual Project 0 due Jan 24 Process Mandatory reading: The Agile Manifesto (this should take under a minute to read, but I suggest you think about what it is advocating for at least a few minutes before moving onto the next article), Hosking’s Agile Projects Have Become Waterfall Projects With Sprints, and the Individual Project 1 Specification Optional reading: Anda et al.’s Variability and Reproducibility in Software Engineering: A Study of Four Companies that Developed the Same System . Jan 26 Code Review Mandatory reading: Google’s How to do a code review (read all six linked sub-pages in the bulleted list) Optional reading: Bacchelli and Bird’s Expectations, Outcomes, and Challenges Of Modern Code Review . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-2",
    "relUrl": "/calendar/#week-2"
  },"20": {
    "doc": "Calendar",
    "title": "Week 3",
    "content": "Jan 31 Version Control Mandatory reading: Ernst’s Version control concepts and best practices Optional reading: De Rosso et al.’s Purposes, concepts, misfits, and a redesign of git . Feb 2 Working in Teams Mandatory reading: Jackson’s The Google Technical Interview and the Individual Project 2 Specification Optional reading: Behroozi et al.’s Hiring is Broken: What Do Developers Say About Technical Interviews? . Feb 2 Individual Project 1 due ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-3",
    "relUrl": "/calendar/#week-3"
  },"21": {
    "doc": "Calendar",
    "title": "Week 4",
    "content": "Feb 7 Requirements and Specifications (1) Mandatory reading: Spolsky’s How to be a Program Manager and the Group Project Specification Optional reading: Ernst et al.’s The Daikon system for dynamic detection of likely invariants . Feb 7 Project Formation due Feb 9 Requirements and Specifications (2) Mandatory reading: Wayne’s Using Formal Methods at Work Optional reading: Lamport’s Introduction to TLA . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-4",
    "relUrl": "/calendar/#week-4"
  },"22": {
    "doc": "Calendar",
    "title": "Week 5",
    "content": "Feb 14 Testing (1) Mandatory reading: Shore’s The Art of Agile Development: Test-Driven Development Optional reading: Saff and Ernst’s An Experimental Evaluation of Continuous Testing During Development . Feb 16 Testing (2) Mandatory reading: Petrovic’s Mutation Testing Optional reading: Memon et al.’s Taming Google-Scale Continuous Testing . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-5",
    "relUrl": "/calendar/#week-5"
  },"23": {
    "doc": "Calendar",
    "title": "Week 6",
    "content": "Feb 21 Testing (3) Mandatory reading: SQLite’s How SQLite is Tested Optional reading: Barr et al.’s The Oracle Problem in Software Testing: A Survey . Feb 21 Project Plan due Feb 23 Languages Mandatory reading: Howarth’s Why Discord is Switching from Go to Rust Optional reading: Hoare’s Hints on Programming Language Design (shorter than it looks!) . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-6",
    "relUrl": "/calendar/#week-6"
  },"24": {
    "doc": "Calendar",
    "title": "Week 7",
    "content": "Feb 28 Build Systems Mandatory reading: Atwood’s The F5 Key Is Not a Build Process Optional reading: Mokhov et al.’s Build Systems à la Carte . Feb 28 Individual Project 2 due Mar 2 Static Analysis (1) Mandatory reading: Ayewah et al.’s Experiences Using Static Analysis to Find Bugs Optional reading: Bessey et al.’s A Few Billion Lines of Code Later: Using Static Analysis to Find Bugs in the Real World . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-7",
    "relUrl": "/calendar/#week-7"
  },"25": {
    "doc": "Calendar",
    "title": "Week 8",
    "content": "Mar 7 Static Analysis (2) Mandatory reading: Schwartz-Narbonne’s How to integrate formal proofs into software development Optional reading: Chapter 2 (“Abstract Interpretation”) of Ernst’s Notes on Program Analysis . Mar 7 Revised Project Plan due Mar 9 Free and Open-source Software Mandatory reading: Stallman’s Why Open Source Misses the Point of Free Software Optional reading: Terrell et al.’s Gender differences and bias in open source: pull request acceptance of women versus men . Mar 11 First Optional Reading Response due ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-8",
    "relUrl": "/calendar/#week-8"
  },"26": {
    "doc": "Calendar",
    "title": "Week 9",
    "content": "Mar 14 No class - spring break. Mar 16 No class - spring break. ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-9",
    "relUrl": "/calendar/#week-9"
  },"27": {
    "doc": "Calendar",
    "title": "Week 10",
    "content": "Mar 21 Debugging (1) Mandatory reading: Zeil’s Debugging – Using Hypotheses to Track Down the Culprit Optional reading: Ko and Myers’ Designing the WhyLine: A Debugging Interface for Asking Questions about Program Behavior . Mar 23 Debugging (2) Mandatory reading: Zeller’s Automated Debugging: Are We Close? Optional reading: Cleve and Zeller’s Locating Causes of Program Failures . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-10",
    "relUrl": "/calendar/#week-10"
  },"28": {
    "doc": "Calendar",
    "title": "Week 11",
    "content": "Mar 28 No class (Martin has the flu) Mar 30 Software Architecture (1) Mandatory reading: Kästner’s Thinking Like a Software Architect Optional reading: Garlan’s Software Architecture . Mar 30 . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-11",
    "relUrl": "/calendar/#week-11"
  },"29": {
    "doc": "Calendar",
    "title": "Week 12",
    "content": "Apr 4 Software Architecture (2) Mandatory reading: Fowler’s Writing Software Patterns (read up to, but not including, “Common Pattern Forms”) and Lewis and Fowler’s Microservices Optional reading: Kellogg et al.’s Verifying Object Construction . Apr 6 Tech debt, refactoring, and maintenance (1) Mandatory reading: Allman’s Managing Technical Debt Optional reading: Kim et al.’s A Field Study of Refactoring Challenges and Benefits . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-12",
    "relUrl": "/calendar/#week-12"
  },"30": {
    "doc": "Calendar",
    "title": "Week 13",
    "content": "Apr 11 Tech debt, refactoring, and maintenance (2) Mandatory reading: Spolsky’s Things you should never do, part I Optional reading: Malkawi’s The art of software systems development: Reliability, Availability, Maintainability, Performance (RAMP) (read up through the 4 “Cases” and then skip to and read the Discussion) . Apr 13 DevOps (1) Mandatory reading: Sloss’ “Introduction” and Baye’s “Emergency Response” from Google’s Site Reliability Engineering Optional reading: Dean and Barroso’s “The Tail at Scale” . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-13",
    "relUrl": "/calendar/#week-13"
  },"31": {
    "doc": "Calendar",
    "title": "Week 14",
    "content": "Apr 18 DevOps (2) Mandatory reading: Lunney and Lueder’s “Postmortem Culture: Learning from Failure” from Google’s Site Reliability Engineering and Luu’s “Postmortem Lessons” Optional reading: Xu et al.’s “Do Not Blame Users for Misconfiguration” . Apr 20 What is Software Engineering? Mandatory reading: Shaw’s “What makes good research in software engineering?” Optional reading: read 10 abstracts in the latest FSE proceedings and make a list of words you don’t know. Then, look up at least 5 of those words and write a brief definition. Submit the list of words, the 5 definitions, and the titles of the papers whose abstracts you read. (I recommend choosing the ten 10 papers whose titles sound the most interesting to you.) . ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-14",
    "relUrl": "/calendar/#week-14"
  },"32": {
    "doc": "Calendar",
    "title": "Week 15",
    "content": "Apr 25 Software Engineer Panel Mandatory reading: none, but attendance today counts for double participation. Also, submit at least one question before class on Canvas. Optional reading: none . Apr 27 Final Exam (in-class) Practice Exam (key) Final Exam (key . May 2 Second Optional Reading Response due ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-15",
    "relUrl": "/calendar/#week-15"
  },"33": {
    "doc": "Calendar",
    "title": "Week 16",
    "content": "May 4 All group project final deliverables due Exam Slot (8:30AM, Friday May 5) Group project presentations, all final deliverables due BEFOREHAND. Attendence (in-person) is required. At least one group member must bring a laptop with a working local demo of your group project. Location: ECEC 115. May 5 Individual Reflection due ",
    "url": "/~mjk76/teaching/cs490-sp23/calendar/#week-16",
    "relUrl": "/calendar/#week-16"
  },"34": {
    "doc": "How to Read a Paper (Useful for Optional Readings)",
    "title": "What is a research paper?",
    "content": "In computer science, original research is typically published at peer-reviewed conferences. Typically these papers have between two and ten authors, and the paper typically reports on about a person-year’s worth of work (though this can vary widely). The authors will be a mix of junior and senior researchers: anyone who contributed something “intellectually significant” to the paper is typically listed as an author. In most CS sub-disciplines (including software engineering, which is the source for most of the optional readings), author order is indicative: the first author is usually the person who did most of the technical work (e.g., implementing the tool, running the experiments, etc.), and the last author is typically the project leader (often, but not always, the first author’s research advisor). Often, but not always, the first author is a PhD student. To be accepted at a peer-reviewed conference, a research paper must be novel: that is, it must contain some new knowledge or evidence that the research community wasn’t aware of before. This requirement impacts how they are written: a research paper must focus on the specific thing that is novel about it, rather than surveying the field as a whole (though you can find “survey” papers that give an overview of a research area, and if you need to know the current state of a sub-field, looking for a survey paper is the way to go). ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/reading-papers.html#what-is-a-research-paper",
    "relUrl": "/tutorials/reading-papers.html#what-is-a-research-paper"
  },"35": {
    "doc": "How to Read a Paper (Useful for Optional Readings)",
    "title": "External Resources",
    "content": "I highly recommend Keshav’s How to Read a Paper if you’re not sure where to start. This short (3-page) article gives a specific strategy for attacking a research paper. I recommend Griswold’s How to Read an Engineering Research Paper. This short article is more aimed at PhD students. but it helps to explain how a research paper is structured (and might be useful to you to help understand the anatomy of a research paper). ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/reading-papers.html#external-resources",
    "relUrl": "/tutorials/reading-papers.html#external-resources"
  },"36": {
    "doc": "How to Read a Paper (Useful for Optional Readings)",
    "title": "How to Read a Paper (Useful for Optional Readings)",
    "content": "Many of the readings for this course are papers from the research literature. These papers can be intimidating if you haven’t encountered them before. This page contains some suggestions on how to read a research paper, along with links to useful external resources. ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/reading-papers.html",
    "relUrl": "/tutorials/reading-papers.html"
  },"37": {
    "doc": "Individual Project 0: Venusians",
    "title": "Objectives of this Assignment",
    "content": "The objectives for this first assignment are to: . | get you familiar with the basics of Typescript and the VSC/npm ecosystem. | have you re-acquaint yourself with the basics of object-oriented programming, such as classes and objects. | learn to write new code in TypeScript. | . Your assignment will be graded following the rubric embedded in this document. Based on past experiences, we project that this assignment could take you up to 14 hours (depending on your prior preparation). We encourage you to start early so that you can post questions on CampusWire and attend office hours as necessary in order to ensure that you can reach Satisfactory marks across the board. This is an individual assignment. Please post any questions about this assignment on CampusWire. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip0.html#objectives-of-this-assignment",
    "relUrl": "/projects/ip0.html#objectives-of-this-assignment"
  },"38": {
    "doc": "Individual Project 0: Venusians",
    "title": "Problem Statement",
    "content": "Mars is being invaded by Venusians. Here’s a description of the Venusian fleet: . | Each ship has a serial number, a crew, which is a list of Venusians, and a possibly-empty set of daughter ships, each of which is a ship. | Each Venusian has a name, which is a string, and a VSN (Venusian Security Number), which is a number. | When we say “fleet”, we mean a list of ships and their daughters, their daughters’ daughters, etc. | When we say the “fleet of a ship”, we mean the fleet consisting of its daughters. | . EXAMPLE: if ship 1 has daughters ship 11 and ship 12, and ship 11 has daughters 111 and 112, and ship 112 has daughters 1121 and 1122, and none of these ships has any other daughters, then the fleet of ship 1 consists of 1, 11, 12, 111, 112, 1121, and 1122 . Your task is to define TypeScript class Venusian and Ship as follows: . | The class Venusian has a contructor new Venusian(name:string) that returns a Venusian with the given name and a unique VSN. By “unique”, we mean that while your program is running, it must never re-use a VSN. It is OK for your program to re-use the same VSNs if you stop the program and run it again (it need not be a “globally unique” identifier). Venusian names are case-senstive. The class Venusian has the following public methods: . | getName():string returns the name of the Venusian. | getVsn():number returns the VSN of the given Venusian | . | The class Ship has a constructor new Ship(crew:Venusian[], daughters:Ship[]) that returns a ship with the given crew, the given daughters, and a unique serial number (similar to VSNs, the serial number need not be globally unique). The class Ship has the following public methods: . | getCrew():Venusian[] returns the crew of the ship. | getDaughters():Ship[] returns the daughters of the ship. | getSerialNumber():number returns the serial number of the ship | hasWaldo():boolean returns true iff the ship has one or more crew members named Waldo. | totalWaldos():number returns the number of Venusians named “Waldo” that are in the ship or its fleet. Venusians can be in two places at once, so if two Waldos have same VSN, you should count them twice. | removeWaldos():void removes any Venusians named “Waldo” from the crew of the ship. | removeDeepWaldos():void removes any Venusians named Waldo from the crews of the given ship and its fleet. | fleetHasDuplicates():boolean It has come to the attention of the Venusian fleet command that some shipbuilders have been cheating by putting multiple ships with the same serial number in the fleets of their ships. Given a ship, determines whether there are any duplicates among the ship and its fleet. The duplicates may occur anywhere in the ship and its fleet.` | . | . EXAMPLE: in the example above, there are no duplicates. If ship 12 were added to the daughters of ship 111, that would be a duplicate, and applying this function to ship 1 would return true. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip0.html#problem-statement",
    "relUrl": "/projects/ip0.html#problem-statement"
  },"39": {
    "doc": "Individual Project 0: Venusians",
    "title": "Starter Code and Details",
    "content": "We will supply you with starter code in ip0-starter-code.zip. Getting Started . | Download and unpack ip0-starter-code.zip in a fresh directory. You should have a directory ip0 containing package.json, src/ and a bunch of other files. | Open ip0 in VSCode. | Open up the VSCode terminal with ctrl + ~. Alternatively, you can also open a seperate terminal/cmd. Please make sure the shell is in the same folder as your package.json. | Fetch all the necessary dependancies by running npm install. You may not install additional third-party libraries to use in your code beyond what is included in the handout - we will grade your code using the package.json distributed in the handout. | The package also includes some basic sanity tests, which you can run by saying npm test. | . To help you set up a local development environment for this class, we’ve prepared a tutorial for setting up a development environment with NodeJS, VSCode and TypeScript. Additionally, An Absolute Beginner’s Guide to Using npm can help you in getting acquainted with npm. As a reference for getting started with TypeScript, we suggest the book “Programming TypeScript” by Boris Cherny. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip0.html#starter-code-and-details",
    "relUrl": "/projects/ip0.html#starter-code-and-details"
  },"40": {
    "doc": "Individual Project 0: Venusians",
    "title": "Rubric",
    "content": "Your code will be evaluated by automated testing in Gradescope. It will be judged for style using a linter with parameters set in the starter code that we will supply you. Your code must have no linter errors or warnings in order for it to receive any grade. Please note that you can check for linter issues before submitting by running npm run lint; many formatting issues can also be automatically fixed by running npm run format. If your code has no linter errors or warnings, then for each of the 10 methods listed above, you will receive a numeric score of: . | 2 (Satisfactory) | 1 (Meets minimum expecations) | 0 (Not passing) | . We have provided between one and three tests on Gradescope to check each of the ten functions that you have been asked to implement. For each function, the requirements for each of these grades are: . Satisfactory . | Have no errors or warnings reported by the linter | Passes all of the Gradescope tests for this function | . Meets minimum expectations . | Have no errors or warnings reported by the linter | Fails no more than one of the Gradescope tests for this function (while also passing at least one) | . Not Passing . | Does not meet the minimum expectations. | . When we say “no errors reported by the linter”, we mean the following: . | Have no style errors (may have warnings) as reported by npm run-script lint . | Have no @ts-ignore or eslint-disable annotations in the code that you write. | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip0.html#rubric",
    "relUrl": "/projects/ip0.html#rubric"
  },"41": {
    "doc": "Individual Project 0: Venusians",
    "title": "Submission Instructions",
    "content": "Submit your assignment in GradeScope. The easiest way to get into GradeScope the first time is to first sign into Canvas and then click the link on our course for “GradeScope”. You should then also have the option to create an account on GradeScope (if you don’t already have one) so that you can log in to GradeScope directly. Please contact the instructors immediately if you have difficulty accessing the course on GradeScope. Submit your solution to Gradescope in the form of exactly two files, Venusian.ts and Ship.ts. Before submitting, be sure your code passes the sanity tests included in the starter package. GradeScope will provide you with feedback on your submission, providing a numeric score between 0 and 20. You will be able to view the complete output from running the tests and linter on GradeScope. If you have any doubts about the autograder, please contact the course staff immediately. In particular, if you are not able to reproduce and debug test or linter failures on your local machine, please ask the TAs for assistance: otherwise you’ll waste an immense amount of time waiting for the autograder to complete, when you could get the same feedback in seconds running the tests + linter locally. You may submit solutions as many times as you want; only the last submission before the deadline will be counted. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip0.html#submission-instructions",
    "relUrl": "/projects/ip0.html#submission-instructions"
  },"42": {
    "doc": "Individual Project 0: Venusians",
    "title": "Individual Project 0: Venusians",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip0.html",
    "relUrl": "/projects/ip0.html"
  },"43": {
    "doc": "Individual Project 1",
    "title": "Objectives of this assignment",
    "content": "The objectives of this assignment are to: . | Get you familiar with the basics of TypeScript, VSCode, and the project codebase | Learn how to read and write code in TypeScript | Translate high-level requirements into code | Learn how to write unit tests with Jest | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip1.html#objectives-of-this-assignment",
    "relUrl": "/projects/ip1.html#objectives-of-this-assignment"
  },"44": {
    "doc": "Individual Project 1",
    "title": "Getting started with this assignment",
    "content": "Before you begin, be sure to check that you have NodeJS 16.x installed, along with VSCode. We have provided a tutorial on setting up a development environment for this class, and you should be able to re-use most of your setup from IP0. Start by downloading the starter code. Extract the archive and run npm install to fetch the dependencies. Avery has provided you with some very basic sanity tests that you can extend for testing your implementation as you go. Overview of relevant classes . The UML class diagram below shows the three main classes that you will be implementing for this deliverable (InteractableArea, ViewingArea, and ConversationArea), along with several relevant classes that you will need to interact with. For Town and ServerToClientEvents, we show only the most relevant methods. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip1.html#getting-started-with-this-assignment",
    "relUrl": "/projects/ip1.html#getting-started-with-this-assignment"
  },"45": {
    "doc": "Individual Project 1",
    "title": "Grading",
    "content": "This submission will be scored out of 100 points, 90 of which will be automatically awarded by the grading script, with the remaining 10 manually awarded by the course staff. Your code will automatically be evaluated for linter errors and warnings. Submissions that have any linter errors will automatically receive a grade of 0. Do not wait to run the linter until the last minute. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. Your code will be automatically evaluated for functional correctness by a test suite that expands on the core tests that are distributed in the handout. Your tests will be automatically evaluated for functional correctness by a process that will inject bugs into our reference solution: to receive full marks your tests must detect a minimum number of injected bugs. You will not receive detailed feedback on which injected bugs you do or do not find, and you will not receive detailed feedback on which tests you do or do not pass. The autograding script will impose a strict rate limit of 5 submissions per 24 hours. Submissions that fail to grade will not count against the quota. This limit exists to encourage you to start early on this assignment: students generally report that assignments like this take between 3-20 hours. If you start early, you will be able to take full advantage of the resources that we provide to help you succeed: office hours, discussion on CampusWire — and the ability to have a greater total number of submission attempts. Your code will be manually evaluated for conformance to our course style guide. This manual evaluation will account for 10% of your total grade on this assignment. We will manually evaluate your code for style on the following rubric: . To receive all 10 points: . | All new names (e.g. for local variables, methods, and properties) follow the naming conventions defined in our style guide | There are no unused local variables | All public properties and methods (other than getters, setters, and constructors) are documented with JSDoc-style comments that describes what the property/method does, as defined in our style guide | The code and tests that you write generally follows good design principles. In particular, your design should not have duplicated code that could have been refactored into a shared method. | . We will review your code and note each violation of this rubric. We will deduct two points for each violation, up to a maximum of deducting all 10 style points. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip1.html#grading",
    "relUrl": "/projects/ip1.html#grading"
  },"46": {
    "doc": "Individual Project 1",
    "title": "Implementation Tasks",
    "content": "This deliverable has four parts; each part will be graded on its own rubric. You should complete the assignment one part at a time, in the order presented here: . Task 1: Implement and test the abstract class (34 points total) . Your first objective is to implement the abstract class InteractableArea. Avery has provided a skeleton for this class, specifying the properties that are expected and implementing the constructor. There are six methods for you to implement in this class: add, remove, contains, addPlayersWithinBounds and overlaps (we suggest implementing them in this order). The specification for each method is provided in comments in the file, and reproduced below: . View the specification for these methods /** * Adds a new player to this interactable area. * * Adds the player to this area's occupants array, sets the player's * interactableID, informs players in the town that the player's * interactableID has changed, and informs players in the town that * the area has changed. * * Assumes that the player specified is a member of this town. * * @param player Player to add */ public add(player: Player): void; /** * Removes a player from this interactable area. * * Removes the player from this area's occupants array, clears the player's * interactableID, informs players in the town that the player's interactableID * has changed, and informs players in the town that the area has changed * * Assumes that the player specified is an occupant of this interactable area * * @param player Player to remove */ public remove(player: Player): void; /** * Tests if a player location is contained within this InteractableArea. * * This interactable area contains a PlayerLocation if any part of the player * is within any part of this area. * A PlayerLocation specifies only the center (x,y) coordinate of the player; * the width and height of the player are PLAYER_SPRITE_WIDTH and * PLAYER_SPRITE_HEIGHT, respectively * * @param location location to check * * @returns true if location is within this area */ public contains(location: PlayerLocation): boolean; /** * Given a list of players, adds all of the players that are within this * interactable area * * @param allPlayers list of players to examine and potentially add to this * interactable area */ public addPlayersWithinBounds(allPlayers: Player[]); /** * Tests if another InteractableArea overlaps with this . Two InteractableArea's * overlap if it is possible for one player to overlap with both of them * simultaneously. That is: There is an overlap if the rectangles of the two * InteractableAreas overlap, where the rectangles are expanded by * PLAYER_SPRITE_WIDTH/2 in each X dimension and PLAYER_SPRITE_HEIGHT/2 in each Y * dimension. * * @param otherInteractable interactable to checko * * @returns true if a player could be contained within both InteractableAreas * simultaneously */ public overlaps(otherInteractable: InteractableArea): boolean; /** * Emits an event to the players in the town notifying them that this * InteractableArea has changed, passing the model for this * InteractableArea in that event. */ protected _emitAreaChanged(); . Testing: Avery has provided you with test cases for add and remove, as well as some very simple (and incomplete) tests for contains and overlaps. You can run these tests by running the command npx jest --watch InteractableArea, which will automatically re-run the tests as you update the file. You should add tests for addPlayersWithinBounds, and improve the contains and overlaps tests to consider all of the boundary conditions. Please implement these additional tests in the file src/town/InteractableArea.test.ts. Grading for implementation tasks: . | add: 3 points | remove: 3 points | contains: 4 points | addPlayersWithinBounds: 3 points | overlaps: 4 points | . Grading for testing tasks: . | addPlayersWithinBounds: 3 points | contains: . | 7 points for detecting all 10 faults, or | 2 points for detecting at least 3 faults | . | overlaps . | 7 points for detecting all 12 faults, or | 5 points for detecting at least 8 faults | . | . Task 2: Implement and test the ConversationArea (15 points total) . Now that we have the core functionality for the InteractableArea abstraction implemented, we can move on to implement one of its concrete instantiations: the ConversationArea. The ConversationArea specialized the InteractableArea, storing a topic field to represent the current topic of the conversation, which is included in the corresponding ConversationAreaModel. The ConversationArea has the same semantics for add(Player) as its generic supertype, and adds a special behavior to the remove(Player) method. When the last player exits a ConversationArea, the topic field for that ConversationArea should be reset to undefined, and an update should be emitted to players in the town (by invoking this._emitAreaChanged()). For this task, Avery has provided the complete test suite for remove, however, you will need to provide a complete set of tests for toModel and fromMapObject. Please add these tests to the existing test suite in src/town/ConversationArea.test.ts. You can run these tests by running the command npx jest --watch ConversationArea, which will automatically re-run the tests as you update the file. View the specification for these methods /** * Convert this ConversationArea instance to a simple ConversationAreaModel * suitable for transporting over a socket to a client. */ public toModel(): ConversationAreaModel; /** * Removes a player from this conversation area. * * Extends the base behavior of InteractableArea to set the topic of this * ConversationArea to undefined and emit an update to other players in the * town when the last player leaves. * * @param player */ public remove(player: Player); /** * Creates a new ConversationArea object that will represent a Conversation Area * object in the town map. * * @param mapObject An ITiledMapObject that represents a rectangle in which this * conversation area exists * @param broadcastEmitter An emitter that can be used by this conversation area * to broadcast updates * @returns */ public static fromMapObject(mapObject: ITiledMapObject, broadcastEmitter: TownEmitter): ConversationArea; . (Added 9/12) fromMapObject should create the BoundingBox from the mapObject using its fields: x, y, width, height. The id of the corresponding InteractableArea should match the name property of the mapObject. If it is helpful: fromMapObject may throw an error if the mapObject is invalid. Grading for implementation tasks: . | toModel: 3 points | remove: 3 points | fromMapObject: 3 points | . Grading for testing tasks: . | toModel: 3 points | fromMapObject: 3 points | . Task 3: Implement and test the ViewingArea (21 points total) . The ViewingArea specializes InteractableArea to store the state of the viewing area, these three properties: video (a string, representing the URL of the video to be played or undefined if none is set), isPlaying (a boolean, representing whether the video should be shown as playing or paused), and elapsedTimeSec (a number, representing the number of seconds elapsed in the playback of the video). Like the ConversationArea, the ViewingArea specializes the behavior of remove, in this case setting the video property to undefined and emitting this update to the players in the town when the last player leaves the ViewingArea. The ViewingArea also adds a new method, updateModel, which will be used in the next deliverable to apply updates to the ViewingAreas state while clients are playing videos. Avery has again provided a complete test suite for remove, and will expect you to provide a complete set of tests for updateModel, toModel and fromMapObject. Please add these tests in the src/town/ViewingArea.test.ts file. You can run these tests by running the command npx jest --watch ViewingArea, which will automatically re-run the tests as you update the file. View the specification for these methods /** * Removes a player from this viewing area. * * When the last player leaves, this method clears the video of this area and * emits that update to all of the players * * @param player */ public remove(player: Player): void; /** * Updates the state of this ViewingArea, setting the video, isPlaying and progress properties * * @param viewingArea updated model */ public updateModel({ isPlaying, progress, video }: ViewingAreaModel); /** * Convert this ViewingArea instance to a simple ViewingAreaModel suitable for * transporting over a socket to a client. */ public toModel(): ViewingAreaModel; /** * Creates a new ViewingArea object that will represent a Viewing Area object in the town map. * @param mapObject An ITiledMapObject that represents a rectangle in which this viewing area exists * @param townEmitter An emitter that can be used by this viewing area to broadcast updates to players in the town * @returns */ public static fromMapObject(mapObject: ITiledMapObject, townEmitter: TownEmitter): ViewingArea; . (Added 9/12) fromMapObject should create the BoundingBox from the mapObject using its fields: x, y, width, height. The id of the corresponding InteractableArea should match the name property of the mapObject. If it is helpful: fromMapObject may throw an error if the mapObject is invalid. Grading for implementation tasks: . | remove: 3 points | updateModel: 3 points | toModel: 3 points | fromMapObject: 3 points | . Grading for testing tasks: . | updateModel: 3 points | toModel: 3 points | fromMapObject: 3 points | . Task 4: Implement and test createInteractablesFromMap (20 points total) . Your last task for this deliverable is to implement a function to validate the InteractableAreas defined in the town’s map file and populate the Town with instances of ViewingArea and ConversationArea to represent those areas. Implement this function in the method initializeFromMap in src/town/Town.ts. Avery has provided you with a single test case that you can use to check your progress; you will find that it tests some basic functionality of this function, but does not test the full specification. Please add new tests in the same describe block as the existing one in src/town/Town.test.ts. You can run these tests by running the command npx jest --watch Town.test, which will automatically re-run the tests as you update the file. Hint: The function takes as a parameter an ITiledMap object; you can learn more about the structure from reviewing the type definition, from the Tiled JSON Map Format Specification, and from the example provided in the test case for initializeFromMap in the handout. The specific layer of the map that you are looking for will be of the type ITiledMapObjectLayer. The object layer will list all of the objects. The type property of each object in that layer identifies it as a ViewingArea, ConversationArea, or other - you can ignore any others. Note: The grading script will also run two integration tests as part of grading this task. The integration tests will check for the behavior of every single one of the methods that you were required t complete for this and the other tasks. While we aim to create test suites for each individual implementation task that are perfect, this is at times a difficult task, and these two integration tests check how the different units interact. These two tests are clearly identified as integration tests in the grading output. Note: Do not try to replicate these integration tests in your tests for initializeFromMap. We will only grade your tests for initializeFromMap on their ability to find defects in our implementation of initializeFromMap, and not in any other functions. Grading: . | 10 points for a correct implementation | 10 points for tests: . | 10 points for detecting all 15 faults, or | 5 points for detecting at least 6 faults, or | 3 points for detecting at least 1 fault | . | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip1.html#implementation-tasks",
    "relUrl": "/projects/ip1.html#implementation-tasks"
  },"47": {
    "doc": "Individual Project 1",
    "title": "Submission Instructions",
    "content": "Submit your assignment in GradeScope. The easiest way to get into GradeScope the first time is to first sign into Canvas and then click the link on our course for “GradeScope”. You should then also have the option to create an account on GradeScope (if you don’t already have one) so that you can log in to GradeScope directly. Please contact the instructors immediately if you have difficulty accessing the course on GradeScope. To submit your assignment: upload only the files: . | src/town/InteractableArea.ts | src/town/InteractableArea.test.ts | src/town/ConversationArea.ts | src/town/ConversationArea.test.ts | src/town/ViewingArea.ts | src/town/ViewingArea.test.ts | src/town/Town.test.ts | src/town/Town.ts | . The grading script should also accept your submission if you upload only a subset of these files. GradeScope will provide you with feedback on your submission, but note that it will not include any marks that will be assigned after we manually grade your submission for code style (it will show 0 for this until it is graded). It may take several minutes for the grading script to complete. GradeScope is configured to only provide feedback on at most 5 submissions per-24-hours per-student (submissions that fail to run or receive a grade of 0 are not counted in that limit). We strongly encourage you to lint and test your submission on your local development machine, and not rely on GradeScope for providing grading feedback - relying on GradeScope is a very slow feedback loop. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip1.html#submission-instructions",
    "relUrl": "/projects/ip1.html#submission-instructions"
  },"48": {
    "doc": "Individual Project 1",
    "title": "Individual Project 1",
    "content": "Welcome aboard to the Covey.Town team! We’re glad that you’re here and ready to join our development team as a new software engineer. We’re building an open source virtual meeting application, and are very happy to see that we have so many new developers who can help make this application a reality. By the end of the semester, you’ll be able to propose, design, implement and test a new feature for our project. We understand that some of you may have some web development experience, but don’t expect that most of you do, and hence, have created an individual project to help you get up to speed with our existing codebase and development environment. Covey.Town is a web application that consists of some code that runs in each client’s web browser, and also code that runs on a server. Users join the application in a “town”: a 2D arcade-style map with different rooms to explore. Each town is also a video call: when two players get close to each other, they can see and hear each other; there is also a text chat available within the town. In Winter of 2021, our lead software engineer, Avery, developed a prototype for Covey.Town, and since then, hundreds of students have built on that codebase. A recent effort added a concept called Conversation Areas, allowing players to post a textual description of the topic of their conversation, and making those video conversations private to those players standing within that same area. Many recent student projects in (some of which are publicly showcased: e.g., Spring 2022 CS 4530 at Northeastern University) involved creating other kinds of flexible interactions that involve objects in the arcade game, other elements displayed in the browser, and video chat. For example: students created game areas, where players who approached a game board could play a simple game (like tic-tac-toe) together; others created bulletin boards that stored persistent messages; others created viewing areas that allowed multiple players to simultaneously playback the same video as a “watch party.” . After studying all of the student projects and their implementation challenges, our lead software engineer, Avery, has refactored Covey.Town, designing a new abstraction to make it easier to create features like these. Avery’s new abstraction, InteractableArea, is a region of the town that provides some interactive elements for players when they enter. The abstraction cuts across the entire technology stack: InteractableAreas exist in the 2D map and the application automatically tracks when players enter and exit them. By pressing the spacebar within an InteractableArea, the user can trigger an interaction with that area, which in turn can be easily used to display new content in the web app using React. An InteractableArea in one user’s browser can also emit events that are delivered in real-time to other players interacting with that same area. The objective for this semester’s individual project is to implement this new InteractableArea abstraction, with two concrete implementations: ConversationArea and ViewingArea. While the ConversationArea will be implemented by refactoring old code to use the new interface, the ViewingArea is a new concept. The ViewingArea allows players to have “watch parties”: each player who is within the ViewingArea sees the same streaming video. If one player pauses the video, it pauses for all other players watching it, and the playback is synchronized between all players watching the video. This implementation effort will be split across two deliverables. In this first deliverable, you will implement and test the core backend components for this feature, and in the second deliverable, you will connect these new components to the rest of the backend, and implement and test the frontend components. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip1.html",
    "relUrl": "/projects/ip1.html"
  },"49": {
    "doc": "Individual Project 2",
    "title": "Objectives of this assignment",
    "content": "The objectives of this assignment are to: . | Write new TypeScript code that uses asynchronous operations | Write test cases that utilize mocks and spies | Write React components and hooks that make use of state | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip2.html#objectives-of-this-assignment",
    "relUrl": "/projects/ip2.html#objectives-of-this-assignment"
  },"50": {
    "doc": "Individual Project 2",
    "title": "Getting started with this assignment",
    "content": "Start by downloading the starter code. Extract the archive and run npm install to fetch the dependencies. Installation notes . Configuring Jest and VSCode: If you would like to use the built-in Jest test runner for VSCode (where it shows the tests and their status in the sidebar), the easiest way to accomplish this for this project is to open just the “frontend” directory or just the “townService” directory in VSCode - not the top-level “ip2-handout” directory. If you have a quick-fix to make it work with the whole project at once, please feel free to share on CampusWire and we will incorportate that here. NPM install failures: The libraries used for React require some native binaries to be installed – code written and compiled for your computer (not JavaScript). If you run into issues with npm install not succeeding, please try installing the following libraries using either Homebrew (if on Mac), apt-get, or your favorite other package manager: pixman, cairo, pkgconfig and pango. For example, run brew install pixman cairo pkgconfig pango. If you are on a newer Mac with an M1 or M2 chip, you may need to use arch -arm64 brew install pixman cairo pango. On Windows: Students have reported seeing the failure error /bin/bash: node: command not found upon npm install in the frontend directory. If you encounter this error, please try to delete the node_modules directory and re-run npm install in the frontend directory from a bash shell instead of a windows command prompt. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip2.html#getting-started-with-this-assignment",
    "relUrl": "/projects/ip2.html#getting-started-with-this-assignment"
  },"51": {
    "doc": "Individual Project 2",
    "title": "Grading",
    "content": "This submission will be scored out of 200 points, 180 of which will be automatically awarded by the grading script, with the remaining 20 manually awarded by the course staff. Your code will automatically be evaluated for linter errors and warnings. Submissions that have any linter errors will automatically receive a grade of 0. Do not wait to run the linter until the last minute. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. Your code will be automatically evaluated for functional correctness by a test suite that expands on the core tests that are distributed in the handout. Your tests will be automatically evaluated for functional correctness by a process that will inject bugs into our reference solution: to receive full marks your tests must detect a minimum number of injected bugs. You will not receive detailed feedback on which injected bugs you do or do not find. The autograding script will impose a strict rate limit of 5 submissions per 24 hours. Submissions that fail to grade will not count against the quota. This limit exists to encourage you to start early on this assignment: students generally report that assignments like this take between 10-36 hours. If you start early, you will be able to take full advantage of the resources that we provide to help you succeed: office hours, discussion on CampusWire — and the ability to have a greater total number of submission attempts. Your code will be manually evaluated for conformance to our course style guide. This manual evaluation will account for 10% of your total grade on this assignment. We will manually evaluate your code for style on the following rubric: . To receive all 20 points: . | All new names (e.g. for local variables, methods, and properties) follow the naming conventions defined in our style guide | There are no unused local variables | All public properties and methods (other than getters, setters, and constructors) are documented with JSDoc-style comments that describes what the property/method does, as defined in our style guide | The code and tests that you write generally follows the design principles discussed in week one. In particular, your design does not have duplicated code that could have been refactored into a shared method. | . We will review your code and note each violation of this rubric. We will deduct four points for each violation, up to a maximum of deducting all 20 style points. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip2.html#grading",
    "relUrl": "/projects/ip2.html#grading"
  },"52": {
    "doc": "Individual Project 2",
    "title": "Implementation Tasks",
    "content": "This deliverable has four parts; each part will be graded on its own rubric. You should complete the assignment one part at a time, in the order presented here: . Task 1: Implement Backend Handlers (15 points total) . In your last deliverable for the indivdiual project, you implemented a considerable portion of the backend code to support Interactables. What remains are the public-facing web service APIs that the client can directly invoke. These methods are located in two files: . | townService/src/town/Town.ts (socket.on('interactableUpdate') handler and addViewingArea) | townService/src/town/TownsController.ts (createViewingArea) | . The socket.on handler is automatically invoked by the socket-io library when an event is received from a remote client. The createViewingArea function is automatically invoked by the tsoa REST middleware when a REST request is made by a remote client. For the purposes of this assignment you need only implement the functions as specified (such that they pass the provided test cases). To run the tests for this part, run the command npm test TestName in the townService directory, where TestName is either Town.test or TownsController. Clarification: A viewing area is “active” if there is a video set. View the specification for these tasks //townService/src/town/Town.ts /** * Creates a new viewing area in this town if there is not currently an active * viewing area with the same ID. The viewing area ID must match the name of a * viewing area that exists in this town's map, and the viewing area must not * already have a video set. * * If successful creating the viewing area, this method: * Adds any players who are in the region defined by the viewing area to it * Notifies all players in the town that the viewing area has been updated by * emitting an interactableUpdate event * * @param viewingArea Information describing the viewing area to create. * * @returns True if the viewing area was created or false if there is no known * viewing area with the specified ID or if there is already an active viewing area * with the specified ID or if there is no video URL specified */ public addViewingArea(viewingArea: ViewingAreaModel): boolean // townService/src/town/TownsController.ts /** * Creates a viewing area in a given town * * @param townID ID of the town in which to create the new viewing area * @param sessionToken session token of the player making the request, must * match the session token returned when the player joined the town * @param requestBody The new viewing area to create * * @throws InvalidParametersError if the session token is not valid, or if the * viewing area could not be created */ @Post('{townID}/viewingArea') @Response&lt;InvalidParametersError&gt;(400, 'Invalid values specified') public async createViewingArea( @Path() townID: string, @Header('X-Session-Token') sessionToken: string, @Body() requestBody: ViewingArea, ): Promise&lt;void&gt; // townService/src/town/Town.ts // Set up a listener to process updates to interactables. // Currently only knows how to process updates for ViewingArea's, and // ignores any other updates for any other kind of interactable. // For ViewingArea's: Uses the 'newPlayer' object's 'towmEmitter' to forward // the interactableUpdate to the other players in the town. Also dispatches an // updateModel call to the viewingArea that corresponds to the interactable being // updated. Does not throw an error if the specified viewing area does not exist. socket.on('interactableUpdate', (update: Interactable) =&gt; {}); . Grading for Task 1: . You do not need to write any tests for task 1. The handout contains all of the tests that our grading script will use. Point break down for each of the implementation tasks: . | Implement Town.ts socket.on(‘interactableUpdate’): 5 points | Implement Town.ts addViewingArea: 5 points | Implement TownController.ts createViewingArea: 5 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. Task 2: Implement and Test Frontend Controllers (65 points total) . Similar to the organization of the backend townService, the frontend application also has controllers that maintain the state of each interactable. The relevant files for this task are located in the directory frontend/src/classes/. The TownController interacts with the townService, receiving ServerToClientEvents from the backend and emitting ClientToServerEvents to the backend. The TownController, in turn, emits TownEvents to components in the frontend. These events are the events that the GUI components will observe. Each Viewing Area is represented by a ViewingAreaController, which emits ViewingAreaEvents. Each Conversation Area is represented by a ConversationAreaController, which emits ConversationAreaEvents. GUI components that display details about each converation area or viewing area will subscribe to these events so that they can remain up-to-date with the current state of the interactable. Your next task is to implement the ViewingAreaController and ConversationAreaController, along with the event handler for TownController to receive interactableUpdate messages from the townService. Each of these classes are stubbed out in the handout. Our handout does not include all of the tests in ViewingAreaController.test.ts or ConversationAreaController.test.ts. To receive full marks on task 2, you will also need enhance these test suites to check all of the behaviors of the methods that you are implementing. Testing the behavior of the ViewingAreaController and ConversationAreaController will require you to use mocks. The ViewingAreaController.test.ts and ConversationAreaController.test.ts files in the handout contain all of the setup code that you will need to write tests to check that the correct listeners are invoked. The mockListeners object (in each test) are mock objects, which do not provide any implementation of the listener callbacks, but keep track of when they have been called. In this way, you can write an assertion that some listener method is called by asserting that the mock listener was called. To write an assertion that, for example, the occupantsChange listener is invoked in ConversationAreaController, you could use Jest’s toHaveBeenCalled() matcher, as in: expect(mockListeners.occupantsChange).toHaveBeenCalled(). You might also find it useful to use the toHaveBeenCalledWith(args..) matcher to check the arguments that are passed to the listener. To assert that a listener was not called, chain the not matcher, as in expect(...).not.toHaveBeenCalled(). We strongly suggest writing the tests before (or concurrent) with implementing the classes, so that you can use your own tests to help you develop your implementation. Note: you may find it useful to use the helper methods isConversationArea and isViewingArea, defined in TypeUtils.ts . To run the tests for this part, run the command npm test TestName in the frontend directory, where TestName is either ViewingAreaController, ConversationAreaController, or TownController. View the specification for these tasks ConversationAreaController: . /** * Create a new ConversationAreaController * @param id * @param topic */ constructor(id: string, topic?: string) { super(); this._id = id; this._topic = topic; } /** * The ID of this conversation area (read only) */ get id() /** * The list of occupants in this conversation area. Changing the set of occupants * will emit an occupantsChange event. */ set occupants(newOccupants: PlayerController[]) get occupants() /** * The topic of the conversation area. Changing the topic will emit a topicChange event * * Setting the topic to the value `undefined` will indicate that the conversation area is not active */ set topic(newTopic: string | undefined) get topic(): string | undefined /** * A conversation area is empty if there are no occupants in it, or the topic is undefined. */ isEmpty(): boolean /** * Return a representation of this ConversationAreaController that matches the * townService's representation and is suitable for transmitting over the network. */ toConversationAreaModel(): ConversationAreaModel . ViewingAreaController . /** * Constructs a new ViewingAreaController, initialized with the state of the * provided viewingAreaModel. * * @param viewingAreaModel The viewing area model that this controller should represent */ constructor(viewingAreaModel: ViewingAreaModel) /** * The ID of the viewing area represented by this viewing area controller * This property is read-only: once a ViewingAreaController is created, it will always be * tied to the same viewing area ID. */ public get id() /** * The URL of the video assigned to this viewing area, or undefined if there is not one. */ public get video() /** * The URL of the video assigned to this viewing area, or undefined if there is not one. * * Changing this value will emit a 'videoChange' event to listeners */ public set video(video: string | undefined) /** * The playback position of the video, in seconds (a floating point number) */ public get elapsedTimeSec() /** * The playback position of the video, in seconds (a floating point number) * * Changing this value will emit a 'progressChange' event to listeners */ public set elapsedTimeSec(elapsedTimeSec: number) /** * The playback state - true indicating that the video is playing, false indicating * that the video is paused. */ public get isPlaying() /** * The playback state - true indicating that the video is playing, false indicating * that the video is paused. * * Changing this value will emit a 'playbackChange' event to listeners */ public set isPlaying(isPlaying: boolean) /** * @returns ViewingAreaModel that represents the current state of this ViewingAreaController */ public viewingAreaModel(): ViewingAreaModel . TownController socket.on('interactableUpdate') . /** * When an interactable's state changes, push that update into the relevant controller, which is assumed * to be either a Viewing Area or a Conversation Area, and which is assumed to already be represented by a * ViewingAreaController or ConversationAreaController that this TownController has. * * If a conversation area transitions from empty to occupied (or occupied to empty), this handler will emit * a conversationAreasChagned event to listeners of this TownController. * * If the update changes properties of the interactable, the interactable is also expected to emit its own * events (@see ViewingAreaController and @see ConversationAreaController) */ this._socket.on('interactableUpdate', interactable =&gt; {}) . Grading for Task 2: . Point break down for each of the implementation tasks: . | Implement ConversationAreaController: 7 points | Implement ViewingAreaController: 7 points | Implement TownController.interactableUpdate: 6 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. Point break down for each of the testing tasks: . | Test ConversationAreaController occupants property: 7 points | Test ConversationAreaController topic property: 7 points | Test ConversationAreaController isEmpty: 7 points | Test ConversationAreaController toConversationAreaModel: 2 points | Test ViewingAreaController video property: 7 points | Test ViewingAreaController elapsedTimeSec property: 7 points | Test ViewingAreaController isPlaying property: 7 points | Test ViewingAreaController viewingAreaModel: 1 points | . Partial marks are available for detecting some (but not all) faults. The number of faults detected may not directly correlate with the difficulty of writing the test: there are several faults that are nearly guaranteed to be detected together (writing a test that finds one of them is guaranteed to find both of them), which is why there are different cutoffs for partial and full marks for the tests. Task 3: Implement React Hooks (60 points total) . An effective pattern for building React applications is to use hooks within components to access global state. As part of the refactoring to implement the Interactable abstraction throughout Covey.Town, Avery also refactored the entire React-based frontend to use this pattern of hooks. Before implementing the final component that displays and synchronizes video playback in Viewing Areas, your next task will be to implement these hooks - some of which are related to the interactables, and some of which are related to Avery’s overall refactoring to use more hooks. Some of these hooks may require you to include useEffect and/or useState hooks within the hook that you are building. For each of the hooks, consider the events that they might need to listen to (i.e. TownEvents for the hooks that monitor a TownController and ConversationAreaEvents for those that monitor a ConversationAreaController). Hooks that need to monitor TownController events may require you to use our own useTownController() hook, which returns the current TownController. The sequence diagram below shows the expected interactions between hooks that subscribe to TownEvents, indicating the interfaces that the hook uses: . Be sure to follow the rules of hooks when implementing your hooks - these will be enforced by the linter, and also by the TAs when grading for style. To run the tests for this part, run the command npm test hooks in the frontend directory. View the specification for the hooks In frontend/src/classes/TownController.ts . /** * A react hook to retrieve the settings for this town * * This hook will cause components that use it to re-render when the settings change. * * This hook relies on the TownControllerContext. * @returns an object with the properties \"friendlyName\" and \"isPubliclyListed\", * representing the current settings of the current town */ export function useTownSettings() /** * A react hook to retrieve the active conversation areas. This hook will re-render any components * that use it when the set of conversation areas changes. It does *not* re-render its dependent components * when the state of one of those areas changes - if that is desired, @see useConversationAreaTopic and @see useConversationAreaOccupants * * This hook relies on the TownControllerContext. * * @returns the list of conversation area controllers that are currently \"active\" */ export function useActiveConversationAreas(): ConversationAreaController[] /** * A react hook to return the PlayerController's corresponding to each player in the town. * * This hook will cause components that use it to re-render when the set of players in the town changes. * * This hook will *not* trigger re-renders if a player moves. * * This hook relies on the TownControllerContext. * * @returns an array of PlayerController's, representing the current set of players in the town */ export function usePlayers(): PlayerController[] . In frontend/src/classes/ConversationAreaController.ts: . /** * A react hook to retrieve the occupants of a ConversationAreaController, returning an array of PlayerController. * * This hook will re-render any components that use it when the set of occupants changes. */ export function useConversationAreaOccupants(area: ConversationAreaController): PlayerController[] /** * A react hook to retrieve the topic of a ConversationAreaController. * If there is currently no topic defined, it will return NO_TOPIC_STRING. * * This hook will re-render any components that use it when the topic changes. */ export function useConversationAreaTopic(area: ConversationAreaController): string . There are no hooks for the ViewingAreaController at this point - Avery noticed that the data in the ViewingAreaController is only used by at most one component, so felt that it would be an over-eager design optimization to define reusable hooks to access that data now. Grading for Task 3: . You do not need to write any tests for task 3. The handout contains all of the tests that our grading script will use. Point break down for each of the implementation tasks: . | Implement TownController.ts useTownSettings: 12 points | Implement TownController.ts useActiveConversationAreas: 12 points | Implement TownController.ts usePlayers: 12 points | Implement ConversationAreaController.ts useConversationAreaOccupants: 12 points | Implement ConversationAreaController.ts useConversationAreaTopic: 12 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. Task 4: GUI Component for Viewing Area Videos (40 points) . With the controllers implemented, the last task will be to implement the frontend GUI component to play back videos in a Viewing Area. Avery has implemented the skeleton for this component, which also includes a form to set the video for a viewing area if it hasn’t already been set. Your task is to implement the component ViewingAreaVideo, which renders the viewing area’s video and synchronizes playback with the ViewingAreaController. You will find that there is already a skeleton of this component created, which renders a &lt;ReactPlayer&gt; component inside of a &lt;Container&gt;, along with the ID of the ViewingArea. In addition to useState and useEffect, this component will also need to make use of React’s useRef hook. useRef is used to make a reference to a child component - the React documentation shows how useRef is used to make a reference to a text input that can be used from within an event handler. The handout code contains the declaration of a useRef hook and ties that reference to the ReactPlayer component. You will find it necessary to reference the ReactPlayer component in order to retrieve its current playback timecode, and to seek to a new timecode. To run the tests for this part, run the command npm test ViewingAreaVideo in the frontend directory. The specification for this component is provided in comments in the file frontend/src/components/Town/interactables/ViewingAreaVideo.tsx, and reproduced below: . View the specification for this component /** * The ViewingAreaVideo component renders a ViewingArea's video, using the ReactPlayer component. * The URL property of the ReactPlayer is set to the ViewingAreaController's video property, and the isPlaying * property is set, by default, to the controller's isPlaying property. * * The ViewingAreaVideo subscribes to the ViewingAreaController's events, and responds to * playbackChange events by pausing (or resuming) the video playback as appropriate. In response to * progressChange events, the ViewingAreaVideo component will seek the video playback to the same timecode. * To avoid jittering, the playback is allowed to drift by up to ALLOWED_DRIFT before seeking: the video should * not be seek'ed to the newTime from a progressChange event unless the difference between the current time of * the video playback exceeds ALLOWED_DRIFT. * * The ViewingAreaVideo also subscribes to onProgress, onPause, onPlay, and onEnded events of the ReactPlayer. * In response to these events, the ViewingAreaVideo updates the ViewingAreaController's properties, and * uses the TownController to emit a viewing area update. * * @param props: A single property 'controller', which is the ViewingAreaController corresponding to the * current viewing area. */ export function ViewingAreaVideo({ controller, }: { controller: ViewingAreaController; }): JSX.Element . Hints: The playing property of the ReactPlayer will need to be changed during the component’s lifetime: set to false when another player pauses the video, or true when it is resumed. This might be a good use-case for useState. In contrast, seeking the video to a new timecode is accomplished not by changing a property, but by using the instance method seekTo of the ReactPlayer. The handout code already has a useRef() hook to demonstrate how to get a reference to the component. Grading for Task 4: . You do not need to write any tests for task 4. The handout contains all of the tests that our grading script will use. Point break down for each of the implementation tasks: . | Implement ViewingAreaVideo - Set properties of the ReactPlayer: 6 points | Implement ViewingAreaVideo - Bridging events from the ViewingAreaController to the ReactPlayer: 17 points | Implement ViewingAreaVideo - Bridging events from the ReactPlayer to the ViewingAreaController: 17 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip2.html#implementation-tasks",
    "relUrl": "/projects/ip2.html#implementation-tasks"
  },"53": {
    "doc": "Individual Project 2",
    "title": "Submission Instructions",
    "content": "Submit your assignment in GradeScope. To submit your assignment: run the command npm run zip in the top-level directory of the handout. This will produce a file called covey-town.zip which should contain these files: . | townService/src/town/Town.ts | townService/src/town/TownsController.ts | frontend/src/classes/TownController.ts | frontend/src/classes/ConversationAreaController.ts | frontend/src/classes/ConversationAreaController.test.ts | frontend/src/classes/ViewingAreaController.ts | frontend/src/classes/ViewingAreaController.test.ts | frontend/src/components/Town/interactables/ViewingAreaVideo.tsx | . GradeScope will provide you with feedback on your submission, but note that it will not include any marks that will be assigned after we manually grade your submission for code style (it will show 0 for this until it is graded). It may take several minutes for the grading script to complete. GradeScope is configured to only provide feedback on at most 5 submissions per-24-hours per-student (submissions that fail to run or receive a grade of 0 are not counted in that limit). We strongly encourage you to lint and test your submission on your local development machine, and not rely on GradeScope for providing grading feedback - relying on GradeScope is a very slow feedback loop. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip2.html#submission-instructions",
    "relUrl": "/projects/ip2.html#submission-instructions"
  },"54": {
    "doc": "Individual Project 2",
    "title": "Individual Project 2",
    "content": "Welcome back! We were pleased to see your thorough implementation of the new Interactables abstraction in the townService of Covey.Town. While you have been working on these backend features, our UX designer Calin has finished the design of the ViewingAreas feature, and we’re now ready to give you the rest of the feature. Calin found the react-player component, which seems to be a great component to use to implement video playback within Covey.Town. In this (final) deliverable for the ViewingAreas feature, you will create the following components: . | Within the backend townService: REST and socket-io endpoints to process API calls from clients, dispatching them to the controllers delivered in IP1. | Within the frontend application: . | An event handler for the frontend TownController to process interactableUpdate messages dispatched by the townService (you implemented those backend components in IP1). | A ViewingAreaController and ConversationAreaController that will maintain data structures and dispatch events to the UI in response to updates from the TownController | React hooks to update existing React components in response to changes to ViewingAreas, ConversationAreas, and town settings | A React component for the ViewingArea that integrates the react-player with those hooks and controllers | . | . When you complete this deliverable, you should have a fully-functioning implementation of the Viewing Area feature, and a better understanding of the covey.town architecture. This sequence diagram shows the interaction between these high level components to create a new viewing area and play a video back synchronized between multiple frontends. The sequence beings when a user selects a video to play in a viewing area, entering it into the ViewingAreaVideo: . | The ViewingAreaVideo asks the TownController to create a new viewing area with the specified video | The TownController asks the townService to create the new viewing area with the specified video, making a REST call | Assuming that the request was valid, the townService returns success | Assuming that the request was valid, the TownController returns success | The townService broadcasts an interactableUpdate message with the new video URL (happening in parallel with 9) | The TownController receives the interactableUpdate, finds the correct ViewingAreaController and pushes an updateModel event to it | The ViewingAreaController updates its model, and emits a videoChange event to its listeners | The ViewingAreaVideo receives the update, re-renders, and now plays the video | The townService sends the same interactableUpdate to Calin’s frontend, and (6-8) happen in Calin’s frontend | During playback, Avery’s ViewingAreaVideo updates the elapsedTimeSec on the ViewingAreaController | In response to the update from the ViewingAreaVideo, the ViewingAreaController asks the TownController to emit an update to the townService | The TownController emits the interactableUpdate event, notifying the backend of the elapsed playack time | The townService relays that interactableUpdate to other clients, which will ensure that their video playback is synchronized | In parallel to 10-13, Calin’s client emits interactableUpdate updates with their elapsedTimeSec | The townService forwards this update to Avery’s frontend TownController | Avery’s TownController finds the ViewingAreaController responsible for that viewing area, and calls its updateModel method, updating its view of the elapsedTimeSec | The ViewingAreaController emits a progressChange event to its listeners. | The ViewingAreaVideo will seek to the new elapsedTimeSec if it is out of sync | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/ip2.html",
    "relUrl": "/projects/ip2.html"
  },"55": {
    "doc": "Optional Readings",
    "title": "Optional Readings",
    "content": "Each lecture has one or more optional reading assignments. During the semester, you must complete at least two optional readings and do an associated task. Most optional readings are research papers from the software engineering literature: the idea is that you will do a deeper dive on two topics that interest you. If you’re not sure how to approach reading a research paper, there are resources to help you. Some optional readings have a specific task associated with them; if you choose one of those, complete the task and then submit the result on Canvas. If there is no task associated with an optional reading, the task is to write a one-page reaction to the paper that explains what you have learned and submit that to Canvas. (Note that one page is the maximum: it would be wise to use as much of it as you can. Do not use a font smaller than size 10.) There is no required format for your reaction, but you might consider including any or all of the following: . | a one or two paragraph summary of the key points of the paper | a list of the paper’s strengths: what did the paper do well, scientifically? | a list of the paper’s weaknesses: what did the paper do poorly? Did it makes claims you didn’t believe? | a description of how this paper might be useful to a software engineer working in industry (be sure to be specific) | a description of how you might apply a lesson from the paper to your own work, now or in the future | . When you submit an optional reading task, be sure to include in your submission the title of the optional reading. One optional reading is due ~50% of the way through class (this semester, by the end of the day on March 11, which is at the beginning of spring break). The other is due at the end of the semester (this semester, on the last day of courses for the semester, which is May 2). For the first optional reading, you aren’t restricted to readings that are associated with lectures earlier in the semester: you are always welcome to read ahead. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/optional-readings.html",
    "relUrl": "/projects/optional-readings.html"
  },"56": {
    "doc": "Project Final Deliverable",
    "title": "Project: Final Deliverable Due TBD, 11:59pm AoE",
    "content": "The final project deliverable is the implementation (in GitHub) and the documentation turned in to Canvas. It also includes your demo and a poster. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-deliverable.html#project-final-deliverable-due-tbd-1159pm-aoe",
    "relUrl": "/projects/project-deliverable.html#project-final-deliverable-due-tbd-1159pm-aoe"
  },"57": {
    "doc": "Project Final Deliverable",
    "title": "Project Implementation and Documentation",
    "content": "Your final team deliverable will be a “release” of your new feature on GitHub (with tests), and will be accompanied by a demo. Optionally, you may also open a pull request to merge your feature into our main repository (submitting a pull request, or the pull request being merged into our codebase is independent of the grade you receive, but provides a platform for more visibility of your project). ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-deliverable.html#project-implementation-and-documentation",
    "relUrl": "/projects/project-deliverable.html#project-implementation-and-documentation"
  },"58": {
    "doc": "Project Final Deliverable",
    "title": "Contents",
    "content": "Your final team deliverable will include: . | The implementation of your new feature | Automated tests for your new feature | A report that describes how to use your new feature | A poster | . Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own which will include your reflections on: . | The evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? | The software engineering processes that you feel could have been improved in your project: were there any processes that in hindsight, you wish that you followed, or wish that you followed better? | Your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? | . Submission Instructions . Code and documentation . After you have pushed all of your code (and documentation) to your team’s GitHub repository, create a release on GitHub, and apply the tag version final-submission. After your release is created, you’ll find that there is now a .zip that can be downloaded from GitHub that contains a snapshot of your entire repository. Download this zip file, unpack it, and follow the instructions that you provided in your README to double-check that the course staff will be able to run your project locally (this step is handy to make sure that you didn’t forget to include some key files in git). If needed, you can delete the release, make some changes, and re-release up until the deadline. Submit this zip file to Canvas under the assignment “Project: Code Submission”. Submit your report separately to Canvas, under the assignment “Project: Report”. Project Poster &amp; Demo . Each team will submit a poster. Your poster will be a single-page document, that will include the following aspects: . | Short description of the project (OK to reuse text from the project plan/report) | Link to source repo (OK to make the repo public now, or OK to leave as private) | Short description of the technology stack and overall design decisions | Short description of future work that could build on your project - additional features that you think could be interesting, or ideas for refactoring the code. | Screenshots of the feature, visually demonstrating the main functionality that you implemented. | . We’ve created a sample poster for the “Conversation Areas” feature, which you might find useful in deciding how to format your poster. It’s fine to use a different aspect ratio (e.g. portrait instead of landscape), and there are no specific requirements for font size or amount of text. Please try to create a document that you feel represents your project, imagine your target audience as a recruiter for a software engineering role: your goal is to demonstrate that you have some experience working on some non-trivial software engineering project. Posters will be submitted on Canvas, under the assignment “Project: Poster”. We will have live (in-person) demos at the project showcase during the class’ final exam slot. You may (but are not required to) print your poster and bring it with you. Individual Reflection . Create a PDF of your reflection, and submit it to Canvas, under the assignment “Project: Individual Reflection”. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-deliverable.html#contents",
    "relUrl": "/projects/project-deliverable.html#contents"
  },"59": {
    "doc": "Project Final Deliverable",
    "title": "Grading",
    "content": "Each project will be graded by the team’s assigned mentor and one other member of the course staff (including at least one instructor). We do not expect all teams to deliver all of the features that were initially proposed - in the (relatively short!) implementation period, there are sure to be some teams that encounter unexpected technical hurdles. As described in greater detail in the rubrics below, teams that have regular communication with their mentor regarding their project status may be permitted variances to their project scope. For most of the submission components below, we provide two benchmark rubrics: one for a submission that is satisfactory (full marks), and one that would be meeting our minimum expectations (a pass). In practice, when grading projects we will usually assign numeric grades and provide partial credit, using these rubrics as guidelines for those two extremes. In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the marks from a student. We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at meetings with your mentor, through inspecting version control history, through each student’s self-reflection, and through each team’s (or student’s) peer evaluations during and/or at the end of the project. We will make regular efforts to collect and distribute this feedback throughout the project. Our ultimate goal is for all students to participate and receive full marks. Summary of grading . | Planning Documents . | 10% Preliminary Project Plan (already graded) | 10% Revised Project Plan (already submitted) | . | Activities During the Project . | 5% Weekly Meetings with Mentor and Team Surveys | 10% Ongoing development progress, including code reviews | . | Final Deliverables . | Code . | 20% Final implementation of your feature | 10% Final test suite of your feature | . | Report . | 5% Feature Overview | 10% Technical Overview | 10% Process Overview | . | 10% Demonstration &amp; Posters | . | . This adds up to 100%; this sum is worth 45% of the course grade. Here are the detailed rubrics for the final deliverables: . 20% Delivered Features . We will grade each delivered project holistically using the following two rubrics: . Satisfactory: . | Implemented feature satisfies the conditions of satisfaction as proposed by the team and as agreed to by the course staff. If technical difficulties resulted in features being dropped, the project may still earn full marks on “delivered features,” but these difficulties must have been documented with the course staff as you encountered them during development. | Implemented feature can be deployed locally following the instructions provided with the code submission in its README without any debugging by the course staff. | Implemented feature contains no ESLint warnings or errors; does not include any eslint-disable or ts-ignore flags | . Meets minimum requirements: . | Implemented feature largely satisfies acceptance criteria as proposed by the team, but may not meet the course staff’s interpretation of those criteria. | Implemented feature can be deployed locally following the instructions provided with the code submission in its README, with minor debugging by the course staff (e.g., one or two minor missing steps). | The implementation may have some obvious flaws, but largely works without crashing. | Implemented feature does not include any eslint-disable or ts-ignore flag | . 10% Testing . The project must include evidence of testing. Ideally, all new features will be accompanied by fully automated tests, but in some circumstances (particularly when engaging with Phaser, the game library, or Tiled, the map editor), this may not be feasible. If automated tests are not possible, include a discussion of your manual testing strategy, including a script that a future developer could use to manually test the feature. Satisfactory: . | Any new or modified backend features include tests that validate that the feature works as intended. These tests cover the changed code, and also contain well-written assertions that thoroughly check the expected behaviors. | Tests contains no ESLint warnings or errors; does not include any eslint-disable or ts-ignore flags | . Meets minimum requirements: . | Any new or modified backend features include at least one test, which may or may not be an effective test. | Tests may contain ESlint warnings (but no errors); does not include any eslint-disable or ts-ignore flags | . Activities During the Project . 5% Weekly Meetings with Mentor and Team Surveys . Throughout the semester, each team will be meeting with their mentor and with the instructor to discuss their project progress. Attendance at these meetings and demonstrations of progress will, cumulatively, account for 5% of the project grade. You will also be asked to complete Team Surveys and/or Peer evaluations to help track the progress. Note that being present for meetings (both literally and intellectually) with your mentor also factors into your individual Participation and Professionalism grade, so though this is a small part of the project grade, its weight in your final grade is larger. 10% Ongoing development progress, including code reviews . Each team is expected to use their GitHub repository, regularly committing changes while developing their project. You will also be expected to use pull-requests and code reviews. Satisfactory: . | There is a clear development history visible from the git repository: features were delivered incrementally, and not in a single (or several) commits at the end of the project | There is evidence of code review - for example, pull requests that have comments on them | There is a correspondence between commit messages and the technical tasks that they are associated with; there are few (if any) commits with meaningless commits messages like . or Add files via upload. | Each team member has made at least 4 commits over the lifespan of the project | . Meets minimum requirements: . | There is a clear development history visible from the git repository: features were delivered incrementally, and not in a single (or several) commits at the end of the project | Each team member has made at least 2 commits over the lifespan of the project | . Final Report . The final report should consist of three sections: . 5% Report – Feature Overview . Satisfactory: . | The Feature section contains sufficient documentation for a user to interact with your updated version of Covey.Town. | The documentation covers all steps that the user would need to take to exercise all of your user stories. | Screenshots are included that capture the key interactions between a user and your new feature. | Course staff were able to follow these instructions to successfully interact with your project implementation. | The section is at most 4 pages (roughly 2,000 words maximum), NOT including figures. Fewer pages are absolutely acceptable, consider this a rough limit | . Meets minimum requirements: . | The Feature contains documentation for a user to interact with your updated version of Covey.Town, but perhaps does not fully describe how. | The documentation includes at least one or two screenshots, but screenshots do not capture interactions with all of the user stories. | The course staff were able to figure out how to use it through trial and error. | The section is at most 4 pages, NOT including figures. Fewer pages are absolutely acceptable, consider this a rough limit | . 10% Report - Technical Overview . Satisfactory: . | Technical Overview contains a description of any substantive changes to the existing Covey.Town codebase, and of the architecture of your new code. | It uses UML diagrams, CRC cards, state diagrams or any of the other techniques that help describe the structure. | It provides a well-reasoned rationale for why this is the “right” design. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) Meets minimum requirements: . | Technical Overview includes a description of all major changes to the code compared to our existing Covey.Town codebase. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) | . 10% Process Overview . Satisfactory: . | Process overview contains a detailed description of the manner in which agile project management processes were used during the project (i.e., sprints, sprint reviews, retrospectives and blameless reviews). | It provides a summary of what was planned to happen in each sprint vs what actually happened, with a discussion of what was revised as a result. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) | . Meets minimum requirements: . | It provides a summary of what was planned to happen in each sprint vs what actually happened, with a discussion of what was revised as a result. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) | . 10% Demonstration / Posters . Each team will be required to submit a poster and to demonstrate their feature during the final exam slot to their classmates and to the instructor(s) and TA(s). Select projects may be hosted in a project showcase. Here are the projects from Spring 2022 project showcase. Satisfactory: . | Poster is a single page | Poster describes the project clearly | Poster describes technology stack and overall design decisions clearly | Poster describes future work clearly | Poster visually demonstrates your feature well | Demo is functional during the final exam slot and is consistent with the project as described in the rest of your final submission | . Meets minimum requirements: . | Poster is a single page | Poster is missing at most one of the following elements: project description, technology stack/design decisions, future work, visual demo of feature | Demo is functional during the final exam slot and is mostly consistent with the project as described in the rest of your final submission | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-deliverable.html#grading",
    "relUrl": "/projects/project-deliverable.html#grading"
  },"60": {
    "doc": "Project Final Deliverable",
    "title": "Individual Reflection",
    "content": "Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own. Satisfactory completion of all parts of this reflection is required to receive an “A” grade in the course, and may be used to calibrate project scores across multiple team members. The individual reflection also provides an opportunity for students to provide confidential feedback on the performance of their teammates. Project Concept . Reflect on the evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? . Satisfactory: . | Is at least 2 paragraphs long; | Includes at least 1 paragraph describing all variances from original project concept; | Includes at least 1 paragraph of personal reflection on the cause of any variances from the project concept. | . Project Process . Reflect on the evolution of your development process: How did the process by which you designed and implemented evolve from your original project plan? Were there any processes that in hindsight, you wish that you followed, or wish that you followed better? . Satisfactory: . | Is at least 2 paragraphs long; | Includes at least 1 paragraph describing all variances from the software development processes envisioned in your original project plan; | Includes at least 1 paragraph describing software processes (described in class or not) that you wish you had followed, or wish you had followed better, supported by evidence from your personal experience working on the project. | . Project Team . Reflect on your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? Do you think that each of your teammates are deserving of the same grade as you? . Satisfactory: . | Is at least 2 paragraphs long; | Includes at least 1 paragraph reflecting on your own performance as a team member on this project, including what you would have done differently, given what you know now; | Includes at least 1 paragraph reflecting on your overall team dynamic, including strengths and weaknesses. Reflect on how you might have organized your team differently given what you know now. | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-deliverable.html#individual-reflection-1",
    "relUrl": "/projects/project-deliverable.html#individual-reflection-1"
  },"61": {
    "doc": "Project Final Deliverable",
    "title": "Project Final Deliverable",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-deliverable.html",
    "relUrl": "/projects/project-deliverable.html"
  },"62": {
    "doc": "Project Overview",
    "title": "Project Overview",
    "content": "The individual and team project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement a new feature. The codebase that we are be developing on is a remote collaboration tool called Covey.Town. Covey.Town provides a virtual meeting space where different groups of people can have simultaneous video calls, allowing participants to drift between different conversations, just like in real life. Covey.Town is inspired by existing products like Gather.Town, Sococo, and Gatherly.IO — but it is an open source effort, and the features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. Overview of Project Deliverables . | Date | Deliverable | Description | . | 2/7/23 | Team Formation | Specify preferences for teammates | . | 2/21/23 | Preliminary Project Plan | Propose a new feature for Covey.Town that can be planned and implemented within 7 weeks | . | 3/7/23 | Revised Project Plan | Refine the scope of your feature based on staff feedback, define detailed requirements and project acceptance criteria. | . | TBD, one-four days before project showcase | Project Implementation and Documentation | Deliver your new feature, including design documentation and tests | . All assignments are due on the specified date, AoE (i.e., before the beginning of the next day anywhere on Earth, which is at 7am EST the next day). Summary of Project Grading . Your overall project grade (which will account for 45% of your final grade in this course) will be the weighted average of each of the deliverables. | Planning Documents . | 10% Preliminary Project Plan | 10% Revised Project Plan | . | Activities During the Project . | 5% Meetings with Mentor and Team Surveys | 10% Ongoing development progress, including code reviews | . | Final Deliverables . | Code . | 20% Final implementation of your feature | 10% Final test suite of your feature | . | Report . | 5% Feature Overview | 10% Technical Overview | 10% Process Overview | . | 10% Demonstration &amp; Posters | . | . In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the team project grade for a student. We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at meetings, through inspecting version control history, through each students’ self-reflection, and through each students’ peer evaluation (during and/or) at the end of the project. We will make regular efforts to collect and distribute this feedback throughout the project — our ultimate goal is for all students to participate and receive full marks. Team Formation . All projects will be completed in a team of 3-4 students. The very first deliverable for the project will be a team formation survey: you will be able to indicate your preferences for teammates. The instructors will assign students to the teams based on a number of factors including your responses to the survey. Team Meetings with Mentor . Each team will be assigned a member of the course staff as a mentor, who will also serve as your point of contact for project grading. During the week of February 13-17, you will have a “Kickoff Meeting” with your mentor, where you will meet your mentor and have the opportunity to share any early ideas that you might want feedback on before submitting the project pitch. Once project begins in full force, you will have regular meetings with your mentor (scheduled at your team’s and your mentor’s convenience, at least once every two weeks) in order to help ensure that you are making progress on the project, and to help address problems that you encounter (be they technical or non-technical problems). Preliminary Project Plan . All projects will involve frontend and backend development of a new feature for Covey.Town. Once teams have been formed, you and your team will decide what kind of new feature you would like to build. Your feature should be something that can be implemented within the timeframe allotted (5-7 weeks), and will be implemented in a fork of the main Covey.Town codebase. Given that you will be up-to-speed on the Covey.Town codebase (and have been introduced to TypeScript, React, NodeJS, and testing frameworks), and that you will have a team of three or four, we expect that the feature that you propose will be more complex than the feature implemented in the individual projects. The project plan will focus on two sections: . | User stories and conditions of satisfaction that describe the feature that you plan to implement. | Work breakdown: Map your user stories to engineering tasks. Assign each task to a team member (or pair of team members), provide an estimate for how long each task will take, a rationale for that estimate, and schedule those stories into sprints. | . Creating a GitHub Repository . Your team’s development must take place within a private GitHub repository in our GitHub Classroom. To create your repository, each member of your team should follow these instructions: . | Sign in to GitHub.com, and then use our invitation to create a repository with the covey.town codebase. Check to see if one of your groupmates has created a group already - if so, select it to join it. Otherwise, you should enter your group number (e.g. “Group 7Y”) as the team name. | Refresh the page, and it will show a link to your new repository. Click the link to navigate to your new repository. This is the repository you will use for the project. | . This repository will be private, and visible only to your team and the course staff. After the semester ends, you are welcome to make it public - you have complete administrative control of the repository. Revised Project Plan . Based on the feedback that you receive from the course staff, you will revise your preliminary project plan, creating a more detailed plan to implement your new feature. The project plan will include: . | Revised user stories and conditions of satisfaction (based on feedback on the preliminary project plan) | Revised work breakdown (based on feedback on the preliminary project plan) | . Your team will self-organize, as agile teams do, and will use the work breakdown and schedule as the basis for your check-ins with your team’s mentor. Project Implementation and Documentation . You will be assigned a mentor for your project who will work closely with you for the entire project. You will coordinate with the mentor to setup bi-weekly meetings and regular sprint demos. Peer evaluation will also be used. Your final team deliverable will be a “release” of your new feature on GitHub (with tests), and will be accompanied by a demo. Optionally, you may also open a pull request to merge your feature into our main repository (submitting a pull request, or the pull request being merged into our codebase is independent of the grade you receive, but provides a platform for more visiblity of your project). Your final team deliverable will include: . | The implementation of your new feature | Automated tests for your new feature | A report | . Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own, which will include your reflections on: . | The evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? | The software engineering processes that you feel could have been improved in your project: were there any procesess that in hindsight, you wish that you followed, or wish that you followed better? | Your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? | . Finally, you will participate in a “project showcase” during the course’s final exam slot. During this showcase, you’ll take turns demo’ing your new feature to the rest of the class, while the rest of your team views the demos of other teams. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-overview.html",
    "relUrl": "/projects/project-overview.html"
  },"63": {
    "doc": "Project Plan",
    "title": "Project Plan Due Tuesday February 21, 2023, 11:59pm AoE",
    "content": "All projects will involve frontend and backend development of a new feature for Covey.Town. Once teams have been formed, you and your team will decide what kind of new feature you would like to build. Your feature should be something that can be implemented within the timeframe allotted (5 weeks, plus 2 weeks of planning), and will be implemented in a fork of the main Covey.Town codebase. You can play with a demo deployment of the app at app.covey.town, and in the coming weeks, we will provide tutorials and instructions for you to run the entire application in a local development environment, and also to deploy it to the cloud. Given that you will be up-to-speed on the Covey.Town codebase (and have been introduced to TypeScript, React, NodeJS, and testing frameworks), and that you will have a team of three or four, we expect that the feature that you propose will be more complex than the feature implemented in the individual homeworks. Feel free to look at existing systems like Gather.Town, Sococo, Reslash, Screen, and Gatherly.IO for inspiration on new features to build for Covey.Town. Also see the recent NYTimes Magazine article The Race to Fix Fix Virtual Meetings. Examples of features that students might propose include: . | Create some new form of “Interactable” object, such as a whiteboard or game | Create an interface for uploading and choosing between different maps and avatars (will require also learning to use the Phaser3 API) | Add screenreader support - generate a textual representation of the map and what players can do to interact with it | Support real persistence: store data in a database (e.g. Postgres + GraphQL), allow users to register and save a profile (e.g. using Auth0) | Add direct messaging, image messaging, and other chat features | Anything else you can imagine that might be useful to a user of Covey.Town | . Please note that multiple teams might choose to propose the same feature, or a variation of that same feature - this is OK. When considering your project, please keep in mind that you will be allowed to publicly post your project online: while your immediate audience for the project is the course staff, if you are ultimately looking for software engineering jobs or co-ops, this project can be a useful piece of your portfolio. If you build a sufficiently maintainable feature (i.e., if your project is particularly well architected and tested), we will also consider pull requests to merge your feature into the main Covey.Town codebase on GitHub, allowing you to also tell recruiters that you have contributed a feature to an open source project on GitHub! . The project plan will include: . | Introductory problem statement | User stories and acceptance criteria: high level description of how users will interact with your new feature. | Work breakdown: Define engineering tasks that will be necessary to implement your new feature. Map each task to a sprint. | . Your mentor will review your project plan and provide you with feedback on the scope and details provided in this plan. Your team will self-organize, as agile teams do, and will enhance and adapt its plan during the project lifecycle. As such, the primary goal of this document is to begin the planning process, and not to produce a detailed plan that must be followed precisely. The course staff will provide feedback on your project to help ensure that the scope of your project is appropriate. We list page maximums for each section as general guidance of what we are willing to grade. Please do not feel compelled to use all of the pages provided, and remember that a diagram or table can be as expressive (or more) as a comparable amount of text. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-plan.html#project-plan-due-tuesday-february-21-2023-1159pm-aoe",
    "relUrl": "/projects/project-plan.html#project-plan-due-tuesday-february-21-2023-1159pm-aoe"
  },"64": {
    "doc": "Project Plan",
    "title": "Problem Statement, User Stories and Acceptance Criteria (max 4 pages)",
    "content": "Your project plan should begin with a 1-3 paragraph introductory problem statement: what problem in Covey.Town does your (proposed) feature solve? Provide a paragraph (or two) that describes why you are interested in building this feature. Given the problem statement, develop three user stories that show how a user would interact with the feature. User stories are requirements specified in the format “As a &lt; type of user &gt;, I want &lt; some goal &gt; so that &lt; some reason &gt;.” My conditions of satisfaction are &lt; list of common cases and special cases that must work &gt;. You should include three different user stories to describe how users will interact with your feature. Your three user stories should cover the key behavior that your feature will provide. Do not provide more than three user stories. Your problem statement and description of user stories and conditions of satisfaction should be between 2-4 pages. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-plan.html#problem-statement-user-stories-and-acceptance-criteria-max-4-pages",
    "relUrl": "/projects/project-plan.html#problem-statement-user-stories-and-acceptance-criteria-max-4-pages"
  },"65": {
    "doc": "Project Plan",
    "title": "Work Breakdown (max 10 pages)",
    "content": "Given the project concept that you have chosen and the functionality that you expect to implement to satisfy your user stories, define a breakdown of the work that will be necessary to complete the project. A work breakdown includes all of the tasks necessary to accomplish the project, and will be an artifact that we will refer back to throughout the project to evaluate whether you are making satisfactory progress. Consider all of the kinds of tasks that your team will need to perform, including knowledge acquisition, design, implementation, testing and documentation tasks. It is hard to say (generically) how many work items are necessary—not all work items are equally difficult or require the same amount of engineering effort. Each task on the work breakdown should be assigned to exactly one team member, who should provide a “T-Shirt” estimate for how long it will take (along with a justification for that estimate). Consider the dependencies between tasks: perhaps an API needs to be designed and specified before implementation can begin; perhaps your development environment needs to be configured before anything else can proceed. Assign tasks to sprints considering these dependencies. Given the preliminary nature of your project, we do not expect that you will know all of the details about precisely how to implement your feature such that you could break it down into tasks that you feel could be implemented in a day or two. However: Large tasks (those which you can not provide a responsible estimate for) must be accompanied by smaller “research” tasks that can be performed early on in the project, providing clear deadlines by which the task must either be refined into smaller tasks (based on new knowledge gathered), or reworked/abandoned. You might consider even scheduling some of these research tasks to take place during Sprint 0 (immediately after submitting this document). For example: Consider if you were proposing the “Viewing Area” project (the individual project), without the experience of having completed it. It might be difficult to consider how to break down a task like “Implement the frontend components for sychnronized video playback” into something that you could commit to doing within a day or two. Given that this is a task that can be delayed until the end of the project (no other tasks depend on it), it would be wise to consider having some tasks early on in the project, such as: “Find react components that embed YouTube videos,” and “Implement simple video player that does not synchronize playback.” Completing these smaller tasks early would let you both demonstrate that some forward progress is being made, and also allow you to create a much more responsible estimate for how that last, otherwise insurmountably large task would take. Be realistic, and leave time for contingencies and for your other courses. If you are uncertain that some tasks will be feasible, then be sure to include evaluation tasks earlier-on in the project that will allow for “go/no-go” decisions to move forward on a task or drop it. We understand that it is quite difficult to estimate the technical complexity of a new project (as you are doing in the case of this course). We will provide you with feedback on this preliminary project plan, which you will use to produce a revised project plan (due March 7). Throughout the project period, teams will meet regularly with their mentor, who will help track progress on a week-to-week basis and help to determine when adjustments to the project scope are needed. Each work item should contain the following information: . | Task to be performed | User story (or stories) that this task relates to | Team member responsible for completing the task | T-shirt size estimate of how long will be needed to complete the task, using the following buckets: . | Small: Can likely be completed by one team member in one sitting of less than 3-4 hours | Medium: Likely to require involvement of multiple team members, over the course of 1-2 days | Large: Currently unable to provide a responsible estimate. | . | A brief (1-2 sentence max) justification of how you reached the size estimate of the task | Milestone for delivering the task, chosen from one of the following two-week sprints: . | Sprint 0: Feb 21-Mar 3 | Sprint 1: Mar 4-Mar 17 (note that this sprint includes Spring Break, which might impact your planning) | Sprint 2: Mar 18-Mar 31 | Sprint 3: Apr 1-Apr 14 | Spring 4: Apr 15-Apr 28 | . | . (We leave some time between the end of the last sprint and the project showcase for slippage: there are always unexpected bugs, etc., that need to be ironed out. Padding your schedule like this is a good idea!) . Your work breakdown should take the format of a simple textual list. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-plan.html#work-breakdown-max-10-pages",
    "relUrl": "/projects/project-plan.html#work-breakdown-max-10-pages"
  },"66": {
    "doc": "Project Plan",
    "title": "Submission",
    "content": "Your project plan should be submitted as a single PDF in Canvas to the assignment “Preliminary Project Plan.” Each team submits a single document to Canvas: when uploading the submission, your teams should already be present in Canvas. Be sure to tag your team mates. The assignment is due by the end of February 21, AoE. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-plan.html#submission",
    "relUrl": "/projects/project-plan.html#submission"
  },"67": {
    "doc": "Project Plan",
    "title": "Grading",
    "content": "The project plan will account for 10% of your project grade, and will be graded out of 100 points. The grading of the project plan is further broken down as follows: . Introductory problem statement (5 points): . | Receive full marks if there is a narrative consisting of 4-10 sentences that describes a specific problem that your project aims to solve. | Receive partial credit if the narrative is present, but does not describe a problem that the project aims to solve | . User stories (15 points): . Each of the three user stories will account for 5% of your grade on this assignment and graded as follows: . | Receive full marks if: . | The user story fits the problem statement | The user story satisfies the INVEST criteria for good user stories (construed quite broadly) | The user story includes conditions of satisfaction that cover the “normal” expected behavior of the feature, and any relevant error cases | . | . Work breakdown (80 points): . Your work breakdown will be evaluated holistically on the following rubric: . Coverage of tasks needed (20 points): . Receive full marks if the work breakdown includes all (reasonably expected) tasks to implement your feature, considering these kinds of tasks: . | Background research | Design of interfaces and data types | Deployment of third-party services | Implementation | Testing | Documentation | . It is not possible to state generically for all projects whether all of the above types of tasks are necessary. However, we believe that this list is exhaustive (we do not expect other kinds of tasks). Assignment of tasks (10 points): . Receive full marks if: . | Each element on the work breakdown is assigned to one team member | The distribution of tasks of each size are roughly similar between the whole team (no single person is assigned significantly more or fewer tasks of one size) | . Sizing of tasks (40 points): . Receive full marks if each element on the work breakdown: . | Has a size estimate (small, medium, or large) that is provided by the team member assigned the task. | Has a responsible justification for that estimation | Every “large” task: . | Is accompanied by a reasonable explanation of why the team is unnable to provide a responsible estimate | Is accompanied by at least one small or medium task, scheduled well-before the “large” task is due to be completed. We would expect that most of these research tasks are scheduled to sprint 0, or perhaps sprint 1. | . | . Scheduling of tasks (10 points): . Receive full marks if each element on the work breakdown: . | Is assigned to a sprint | There are no obvious constraint violations (tasks that logically must happen before others should be scheduled before them) | There are no “Large” tasks scheduled in sprint 0 | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-plan.html#grading",
    "relUrl": "/projects/project-plan.html#grading"
  },"68": {
    "doc": "Project Plan",
    "title": "Project Plan",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/project-plan.html",
    "relUrl": "/projects/project-plan.html"
  },"69": {
    "doc": "Projects",
    "title": "Projects",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/",
    "relUrl": "/projects/"
  },"70": {
    "doc": "Revised Project Plan",
    "title": "Revised Project Plan Due Tuesday, March 7, 2023 AoE",
    "content": "You should use the feedback on your preliminary project plan to revise the scope of your project, and discuss any changes with your assigned mentor. The goal of this assignment is to finalize the intended scope of your project based on these discussions and to outline the tasks that you will need to accomplish in order to complete your project. Your mentor will review your project plan and provide you with feedback on the scope and details provided in your preliminary plan. In this deliverable, you will revise your project plan based on that feedback, and any preliminary research tasks that you have completed. If there were any deficiencies or concerns noted by your mentor on your preliminary plan, you must address those concerns in this revised plan. If you are unsure of how to address any of these concerns or if you have addressed them, please discuss them with your mentor before submitting this revised plan. We list page maximums for each section as general guidance of what we are willing to grade. Please do not feel compelled to use all of the pages provided, and remember that a diagram or table can be as expressive (or more) as a comparable amount of text. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/revised-project-plan.html#revised-project-plan-due-tuesday-march-7-2023-aoe",
    "relUrl": "/projects/revised-project-plan.html#revised-project-plan-due-tuesday-march-7-2023-aoe"
  },"71": {
    "doc": "Revised Project Plan",
    "title": "Revised Problem Statement, User Stories and Acceptance Criteria (max 4 pages)",
    "content": "Your project plan should begin with a 1-3 paragraph introductory problem statement: what problem in Covey.Town does your (proposed) feature solve? Provide a paragraph (or two) that describes why you are interested in building this feature. Given the problem statement, develop three user stories that show how a user would interact with the feature. User stories are requirements specified in the format “As a &lt; type of user &gt;, I want &lt; some goal &gt; so that &lt; some reason &gt;.” My conditions of satisfaction are &lt; list of common cases and special cases that must work &gt;. Please make sure that your conditions of satification are complete (i.e., cover all common cases) and can be turned into testable behaviors. You should include three different user stories to describe how users will interact with your feature. Your three user stories should cover the key behavior that your feature will provide. Do not provide more than three user stories. Your problem statement and description of user stories and conditions of satisfaction should be between 2-4 pages. This revised project plan should be a standalone document (it is OK to copy/paste from the preliminary plan in this case). Mandatory update for all teams: Along with each condition of satisfaction, indicate its priority (high, medium, low). The priority should help refine your task breakdown. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/revised-project-plan.html#revised-problem-statement-user-stories-and-acceptance-criteria-max-4-pages",
    "relUrl": "/projects/revised-project-plan.html#revised-problem-statement-user-stories-and-acceptance-criteria-max-4-pages"
  },"72": {
    "doc": "Revised Project Plan",
    "title": "Revised Work Breakdown (max 10 pages)",
    "content": "Given the project concept that you have chosen and the functionality that you expect to implement to satisfy your user stories, define a breakdown of the work that will be necessary to complete the project. A work breakdown includes all of the tasks necessary to accomplish the project, and will be an artifact that we will refer back to throughout the project to evaluate whether you are making satisfactory progress. Consider all of the kinds of tasks that your team will need to perform, including knowledge acquisition, design, implementation, testing and documentation tasks. It is hard to say (generically) how many work items are necessary. Each task on the work breakdown should be assigned to exactly one team member, who should provide a “T-Shirt” estimate for how long it will take (along with a justification for that estimate). Consider the dependencies between tasks: perhaps an API needs to be designed and specified before implementation can begin; perhaps your development environment needs to be configured before anything else can proceed. Assign tasks to sprints considering these dependencies. Given the preliminary nature of your project, we do not expect that you will know all of the details about precisely how to implement your feature such that you could break it down into tasks that you feel could be implemented in a day or two. However: Large tasks (those which you can not provide a responsible estimate for) must be accompanied by smaller “research” tasks that can be performed early on in the project, providing clear deadlines by which the task must either be refined into smaller tasks (based on new knowledge gathered), or reworked/abandoned. You might consider even scheduling some of these research tasks to take place during Sprint 0 (immediately after submitting this document). For example: Consider if you were proposing the “Viewing Area” project (the individual project), without the experience of having completed it. It might be difficult to consider how to break down a task like “Implement the frontend components for sychnronized video playback” into something that you could commit to doing within a day or two. Given that this is a task that can be delayed until the end of the project (no other tasks depend on it), it would be wise to consider having some tasks early on in the project, such as: “Find react components that embed YouTube videos,” and “Implement simple video player that does not synchronize playback.” Completing these smaller tasks early would let you both demonstrate that some forward progress is being made, and also allow you to create a much more responsible estimate for how that last, otherwise insurmountably large task would take. Be realistic, and leave time for contingencies and for your other courses. If you are uncertain that some tasks will be feasible, then be sure to include evaluation tasks earlier-on in the project that will allow for “go/no-go” decisions to move forward on a task or drop it. We understand that it is quite difficult to estimate the technical complexity of a new project (as you are doing in the case of this course). Throughout the project period, teams will meet regularly with their dedicated mentor, who will help track progress on a week-to-week basis and help to determine when adjustments to the project scope are needed. Each work item should contain the following information: . | Task to be performed | User story (or stories) that this task relates to | Team member responsible for completing the task | T-shirt size estimate of how long will be needed to complete the task, using the following buckets: . | Small: Can likely be completed by one team member in one sitting of less than 3-4 hours | Medium: Likely to require involvement of multiple team members, over the course of 1-2 days | Large: Currently unable to provide a responsible estimate. | . | A brief (1-2 sentence max) justification of how you reached the size estimate of the task | Milestone for delivering the task, chosen from one of the following: . | Sprint 0: Feb 21-Mar 3 | Sprint 1: Mar 4-Mar 17 (note that this sprint includes Spring Break, which might impact your planning) | Sprint 2: Mar 18-Mar 31 | Sprint 3: Apr 1-Apr 14 | Spring 4: Apr 15-Apr 28 | . | . (We leave some time between the end of the last sprint and the project showcase for slippage: there are always unexpected bugs, etc., that need to be ironed out. Padding your schedule like this is a good idea!) . Your work breakdown should take the format of a simple textual list. Mandatory update for all teams: Even if your work breakdown is entirely unchanged compared to the preliminary plan, please be certain to include updates on all “sprint 0” tasks (those which were scheduled to be completed before the due date of this revised plan). Many teams include research/learning tasks in the first week to help inform the rest of the work breakdown: you should be certain to revise your work breakdown based on what you have learned so far. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/revised-project-plan.html#revised-work-breakdown-max-10-pages",
    "relUrl": "/projects/revised-project-plan.html#revised-work-breakdown-max-10-pages"
  },"73": {
    "doc": "Revised Project Plan",
    "title": "Submission",
    "content": "Your revised project plan should be submitted as a single PDF in Canvas to the assignment “Revised Project Plan.” Each team submits a single document to Canvas. ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/revised-project-plan.html#submission",
    "relUrl": "/projects/revised-project-plan.html#submission"
  },"74": {
    "doc": "Revised Project Plan",
    "title": "Grading",
    "content": "The revised project plan will account for 10% of your project grade, and will be graded out of 100 points. The grading of the revised project plan is further broken down as follows: . Introductory problem statement (5 points): . | Receive full marks if there is a narrative consisting of 4-10 sentences that describes a specific problem that your project aims to solve. | Receive partial credit if the narrative is present, but does not describe a problem that the project aims to solve | . User stories (45 points): . Each of the three user stories will account for 5% of your grade on this assignment and graded as follows: . | Receive full marks if: . | The user story fits the problem statement | The user story satisfies the INVEST criteria for good user stories (construed quite broadly) | The user story includes conditions of satisfaction that cover the “normal” expected behavior of the feature, and any relevant error cases | Conditions of satisfaction can be turned into Testable behaviors | Conditions of satisfaction are prioritized | . | . Work breakdown (50 points): . Your work breakdown will be evaluated holistically on the following rubric: . Coverage of tasks needed (20 points): . Receive full marks if the work breakdown includes all (reasonably expected) tasks to implement your feature, considering these kinds of tasks: . | Background research | Design of interfaces and data types | Deployment of third-party services | Implementation | Testing | Documentation | . It is not possible to state generically for all projects whether all of the above types of tasks are necessary. However, we believe that this list is exhaustive (we do not expect other kinds of tasks). Assignment of tasks (5 points): . Receive full marks if: . | Each element on the work breakdown is assigned to one team member | The distribution of tasks of each size are roughly similar between the whole team (no single person is assigned significantly more or fewer tasks of one size) | . Sizing of tasks (20 points): . Receive full marks if each element on the work breakdown: . | Has a size estimate (small, medium, or large) that is provided by the team member assigned the task. | Has a responsible justification for that estimation | Every “large” task: . | Is accompanied by a reasonable explanation of why the team is unnable to provide a responsible estimate | Is accompanied by at least one small or medium task, scheduled well-before the “large” task is due to be completed. We would expect that most of these research tasks are scheduled to sprint 0, or perhaps sprint 1. | . | . Scheduling of tasks (5 points): . Receive full marks if each element on the work breakdown: . | Is assigned to a sprint | There are no obvious constraint violations (tasks that logically must happen before others should be scheduled before them) | There are no “Large” tasks scheduled in sprint 0 | Tasks scheduled to be completed before 3/7 have an update as to their status, and the work breakdown is updated to reflect the result of these tasks. | . ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/revised-project-plan.html#grading",
    "relUrl": "/projects/revised-project-plan.html#grading"
  },"75": {
    "doc": "Revised Project Plan",
    "title": "Revised Project Plan",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/projects/revised-project-plan.html",
    "relUrl": "/projects/revised-project-plan.html"
  },"76": {
    "doc": "Schedule",
    "title": "Weekly Schedule",
    "content": ". | 9:00 AM | 9:30 AM | 10:00 AM | 10:30 AM | 11:00 AM | 11:30 AM | 12:00 PM | 12:30 PM | 1:00 PM | 1:30 PM | 2:00 PM | 2:30 PM | 3:00 PM | 3:30 PM | 4:00 PM | 4:30 PM | 5:00 PM | 5:30 PM | . | ",
    "url": "/~mjk76/teaching/cs490-sp23/schedule/#weekly-schedule",
    "relUrl": "/schedule/#weekly-schedule"
  },"77": {
    "doc": "Schedule",
    "title": "Monday",
    "content": ". | Tutoring: Rishik 12:00 PM–3:00 PM GITC 3700 | Tutoring: Logan 10:00 AM–11:00 AM GITC 3700 | OH: Martin 1:30 PM–2:30 PM GITC 4314 | OH: Huzefa 4:30 PM–5:30 PM GITC 4234 | . | ",
    "url": "/~mjk76/teaching/cs490-sp23/schedule/",
    "relUrl": "/schedule/"
  },"78": {
    "doc": "Schedule",
    "title": "Tuesday",
    "content": ". | Lecture 11:30 AM–1:00 PM KUPF 203 | OH: Huzefa 6:00 PM–7:00 PM GITC 4234 | . | ",
    "url": "/~mjk76/teaching/cs490-sp23/schedule/",
    "relUrl": "/schedule/"
  },"79": {
    "doc": "Schedule",
    "title": "Wednesday",
    "content": "| ",
    "url": "/~mjk76/teaching/cs490-sp23/schedule/",
    "relUrl": "/schedule/"
  },"80": {
    "doc": "Schedule",
    "title": "Thursday",
    "content": ". | Tutoring: Rishik 5:00 PM–8:00 PM GITC 3700 | Tutoring: Cao 10:00 AM–4:00 PM GITC 3700 | Lecture 11:30 AM–1:00 PM KUPF 203 | . | ",
    "url": "/~mjk76/teaching/cs490-sp23/schedule/",
    "relUrl": "/schedule/"
  },"81": {
    "doc": "Schedule",
    "title": "Friday",
    "content": ". | Tutoring: Palak 12:00 PM–1:00 PM GITC 3700 | . | . ",
    "url": "/~mjk76/teaching/cs490-sp23/schedule/",
    "relUrl": "/schedule/"
  },"82": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/schedule/",
    "relUrl": "/schedule/"
  },"83": {
    "doc": "Staff",
    "title": "Course Staff",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/staff/#course-staff",
    "relUrl": "/staff/#course-staff"
  },"84": {
    "doc": "Staff",
    "title": "Instructors",
    "content": "Martin Kellogg . martin.kellogg@njit.edu . Office Hours: Mondays, 1:30-2:30pm eastern, GITC 4314; or by appointment. To schedule an appointment with me, check my calendar and add a calendar event in any open spot that works for you. In your invitation, you must, at a minimum, 1) invite me to the event and 2) add a note to the event description that mentions CS 490 and what you’d like to meet about. ",
    "url": "/~mjk76/teaching/cs490-sp23/staff/#instructors",
    "relUrl": "/staff/#instructors"
  },"85": {
    "doc": "Staff",
    "title": "Teaching Assistants",
    "content": "Huzefa Pitolwala . hip2@njit.edu . Office Hours: Mondays, 4:30-5:30pm eastern and Tuesdays 6:00-7:00pm eastern, GITC 4234 . ",
    "url": "/~mjk76/teaching/cs490-sp23/staff/#teaching-assistants",
    "relUrl": "/staff/#teaching-assistants"
  },"86": {
    "doc": "Staff",
    "title": "Staff",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/staff/",
    "relUrl": "/staff/"
  },"87": {
    "doc": "Code Style",
    "title": "Code Style",
    "content": "Programs are easier to read and to understand when they are written in a familiar style and follow standard coding conventions. Most organizations that develop software therefore require programmers to write programs that follow the organization’s preferred style and coding conventions. These conventions can be very elaborate. Many of the guidelines are, in fact, arbitrary. When you are working on a coding project with other developers, different developers often have preference for slightly different syntax, for instance: should our string literals be enclosed by single quotes (') or double quotes (\")? Should files be indented with spaces or tabs? In TypeScript, there are often multiple ways to accomplish the same goal, for instance, you could create a new empty array with the expression const myArray = new Array(), or const myArray = []. Sometimes there is no difference between these variants except for how it reads, and other times there may be unintended consequences of making the seemingly correct but subtly wrong choice. Thankfully, it is possible to write automated checkers (and, at times, fixers) for these style violations. All code that you write for this class will be checked by ESLint, and must be free of style warnings and errors. Our ESlint rules are derived from Airbnb’s JavaScript Style Guide, ESLint’s Recommended Rules, TypeScript/ESLint Recommended Rules, React ESLint Rules and React Hooks ESLint Rules. We do not suggest studying these lists directly, instead, begin writing code naturally, and allow your IDE’s built-in style checker to report issues as you find them. The most important rules to get started are: . | Indent using spaces, not tabs; use 2 spaces for each level of indentation | Enclose all string literals with single quotes, not double | Variables must be named using lowerCamelCase, types are named using UpperCamelCase. Constants (read-only variables that are assigned a static value once and not reused) must be named using UPPER_CASE_WITH_UNDERSCORES. | The maximum line length is 100 characters | . Naming . While the linter can automatically flag names that violate camelCase rules, it can not automatically determine that a name is “good” - this is a subjective judgement call. Please consider the following when choosing names: . | Names should be informative (e.g lineTooLong() rather than checkLineLength()) | Names for types are typically nouns or noun phrases. Interface names, however, might be adjectives (e.g. Serializable). Class names may be noun phrases that include the interface name (e.g. CuckooClock and DigitalClock for classes that implement the interface Clock). | Use noun-like names for functions or methods that return values (e.g. circleDiameter rather than calculateDiameter). (Exception: simple getters can still have names that begin with get). | Reserve verb-like names for functions that perform actions (e.g. addItem). | Use adjective phrases for predicates when possible (e.g. line.tooLong()) | Variable and property names should be descriptive of what the variable is for, and not be named after the type of the variable (which is captured in the variable’s type declaration) | Names for properties that are private must start with a _ | . Documentation and Comments . All public properties and methods (other than getters, setters, and constructors) must be documented using JSDoc-style comments that describes what the property/method does. Example: . /** The unique identifier for this player * */ private readonly _id: string; . /** * A handler to process a remote player's subscription to updates for a room * * @param socket the Socket object that we will use to communicate with the player */ . Consider adding comments within your code to describe non-obvious behavior, or to capture why the code is written the way that it is. Do not add comments that simply restate what can already be immediately discerned by reading the code. For example, here is a useful comment: . // No valid session exists for this token, hence this client's connection should be terminated socket.disconnect(true); return; . Here is a useless comment on the same code snippet: . // Disconnect the socket socket.disconnect(true); return; . Comments are for documentation, not for keeping track of old code you are no longer using (do not submit commented-out code). ",
    "url": "/~mjk76/teaching/cs490-sp23/policies/style/",
    "relUrl": "/policies/style/"
  },"88": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/",
    "relUrl": "/tutorials/"
  },"89": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS",
    "content": "Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. For this class, you will need Node.js version 16 (16.17 is the latest version at time of writing, although any 16.x should work in theory). There are many ways that you can install Node.js: for instance, you can use a package manager like snap or homebrew to install it; you can download an installer directly from the Node.js website, and you can, of course, build it from source. However, due to the complexity of running different Node.js versions on the same machine, we very strongly suggest using nvm, as explained below. We recommend installing Node.js using nvm, the node version manager. When language runtimes are in active development (like Node.js is), sometimes you end up needing to have multiple versions of Node.js installed, and different projects that you work on might require different versions of Node.js. These annoyances are quite rare, but when it happens that you need to have mutliple versions of Node.js installed, it’s super handy to have your system set up already so that installing multiple versions and switching between it is easy. You can use our instructions to set up nvm even if you have previously installed Node.js. ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installing-nodejs",
    "relUrl": "/tutorials/week1-getting-started.html#installing-nodejs"
  },"90": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS with NVM for Windows",
    "content": ". | Download nvm-setup.zip from the most recent release of nvm-windows (at time of writing this document, version 1.1.9). | . | Extract the contents of nvm-setup.zip and run the executable nvm-setup.exe. | This should open the nvm installation wizard. | . | Accept the license agreement and click next. Continue to accept the default choices for any remaining prompts, and click “install”. If you receive messages along the lines of “NodeJS version XYZ is already installed, would you like nvm to control this installation,” select “Yes”. | Upon completion, you will see the below window . | . | Open a command prompt with administrative privileges (type cmd in the windows start bar, then select “Run as administrator”). | Verify the installation, run the command nvm version . | This should display the version of nvm installed. | | . | Run the command nvm list available to display all available NodeJS versions. | . | Install the latest LTS (Long term supported, as opposed to the “development”) version of Node.js available using the command nvm install 16.13.2. | To use this version of NodeJS, run the command nvm use 16.13.2. | Now, NodeJS should be installed and ready for use. To verify the installation run the below commands: . | node -v | npm -v | | . | . Troubleshooting with VSCode: Did you follow these instructions successfully, but find a “Command not found” error when you try to run npm in VSCode? Try this: Close VSCode completely. Re-open it. In your command shell in VSCode, try again. We have noticed that if you have VSCode open while installing nvm, it is possible that VSCode will not see the new software installation until it’s closed and re-opened. You can also confirm that VSCode correctly sees the NodeJS installation by running echo %PATH% in your windows command shell in VSCode: it should include an entry similar to C:\\Program Files\\nodejs. ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installing-nodejs-with-nvm-for-windows",
    "relUrl": "/tutorials/week1-getting-started.html#installing-nodejs-with-nvm-for-windows"
  },"91": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Linux / Mac)",
    "content": ". | Run either curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash or wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash. | Close and reopen a terminal. | Verify nvm is working by entering command -v nvm. If your terminal prints out nvm, it should be working. If you see nvm: command not found or no feedback, open a new terminal and trying again or restart from step 1. | Install the latest LTS (Long term supported, as opposed to the “development”) version of Node.js by typing nvm install 16. | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installation-steps-linux--mac",
    "relUrl": "/tutorials/week1-getting-started.html#installation-steps-linux--mac"
  },"92": {
    "doc": "Installing a Development Environment",
    "title": "Verification",
    "content": ". | Open a shell or windows powershell. | Run the command node -v . | This should print the current version of nodeJS installed (v16.x.x) | . | Run the command npm -v . | This should print the current version of npm installed (v8.x.x) | . | If you find that some other version is being used, and would like to change the default to 16, run the command nvm alias default 16 | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#verification",
    "relUrl": "/tutorials/week1-getting-started.html#verification"
  },"93": {
    "doc": "Installing a Development Environment",
    "title": "Installing Visual Studio Code (VSCode)",
    "content": "Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity). VSCode also supports importing hotkey configurations from most other text editors and IDEs. Read more here. While you are required to use an IDE for this class, it is not mandatory to use VSCode: if you already are comfortable developing TypeScript or JavaScript in another suitable IDE (like IntelliJ), then you are welcome to continue to use that. However, VSCode is the “supported” option: if you struggle to get things like the linter set up correctly in VSCode, we will be happy to help you. However, we can’t provide such support for all IDEs. ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installing-visual-studio-code-vscode",
    "relUrl": "/tutorials/week1-getting-started.html#installing-visual-studio-code-vscode"
  },"94": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | Administrative access on the host machine for software installation. | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#pre-requisites",
    "relUrl": "/tutorials/week1-getting-started.html#pre-requisites"
  },"95": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Windows / Mac)",
    "content": ". | Download the VSCode installer from the VSCode website. | . | Run the installer to start the installation wizard for VSCode . | . | Accept the license agreement and click next. | . | Choose the installation directory of your choice and click next. | . | Click next on the select start menu folder screen. | . | Tick all check boxes on the select additional tasks menu and click next. | . | Review the settings on the the “Ready to install” screen and click Install to begin installation. | Once the installation is complete, you will see the below screen and you are ready to use VSCode. | . | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installation-steps-windows--mac",
    "relUrl": "/tutorials/week1-getting-started.html#installation-steps-windows--mac"
  },"96": {
    "doc": "Installing a Development Environment",
    "title": "Installation (Linux)",
    "content": ". | The above instructions for Windows/Mac should also work, but VSCode is also provided as a snap package | . | Install snap if you haven’t already by running sudo apt update and then sudo apt install snapd. | Install VSCode by running sudo snap install --classic code. | Open VSCode as an application on your desktop. | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installation-linux",
    "relUrl": "/tutorials/week1-getting-started.html#installation-linux"
  },"97": {
    "doc": "Installing a Development Environment",
    "title": "Additional Extensions (Optional)",
    "content": "VSCode comes with a rich set of extensions to aid in software development. Below is a list of extensions that you may find useful. | GitLens - Git Supercharged | Prettier - code formatter | vscode-icons | ESLint | Andromeda (Color theme: Andromeda Colorizer) | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#additional-extensions-optional",
    "relUrl": "/tutorials/week1-getting-started.html#additional-extensions-optional"
  },"98": {
    "doc": "Installing a Development Environment",
    "title": "Installing Extensions (eg. ESLint)",
    "content": ". | Click on the extensions tab on the left in VSCode. | Search ESLint. | Click on Install. | Done! . | . | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installing-extensions-eg-eslint",
    "relUrl": "/tutorials/week1-getting-started.html#installing-extensions-eg-eslint"
  },"99": {
    "doc": "Installing a Development Environment",
    "title": "Getting Started With Typescript",
    "content": "Typescript is a superscript of JavaScript which adds type information and other features. ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#getting-started-with-typescript",
    "relUrl": "/tutorials/week1-getting-started.html#getting-started-with-typescript"
  },"100": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | NodeJS | VSCode (recommended but not required) | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#pre-requisites-1",
    "relUrl": "/tutorials/week1-getting-started.html#pre-requisites-1"
  },"101": {
    "doc": "Installing a Development Environment",
    "title": "Installation",
    "content": ". | Open VSCode and press the ctrl + ~ (Tilde or back tick key) to open a terminal. | Optionally you can open a separate shell (Do not use powershell) | . | Run the command npm install -g typescript in the terminal. | Typescript should now be installed globally and accessible from the terminal. | . | Verify the installation using the command tsc -v in the terminal. (Do NOT use powershell) . | . | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#installation",
    "relUrl": "/tutorials/week1-getting-started.html#installation"
  },"102": {
    "doc": "Installing a Development Environment",
    "title": "Hello World",
    "content": ". | Create a new directory and open it with VSCode. | Create a new file called hello-world.ts | Add the following code to the file: console.log('Hello, World!'); . | Open the terminal with ctrl + ~. | Ensure that you are in the same directory as hello-world.ts. | . | Run the command tsc hello-world.ts . | This will generate a JS file called hello-world.js | . | Run the file with node using the command node hello-world.js. | This will give the result below. | | . | . ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html#hello-world",
    "relUrl": "/tutorials/week1-getting-started.html#hello-world"
  },"103": {
    "doc": "Installing a Development Environment",
    "title": "Installing a Development Environment",
    "content": "This tutorial describes the basic steps needed to set up a development environment with NodeJS, TypeScript, and VisualStudio Code. At the end of this tutorial, you should have a complete local development environment that you can use to build and test code for this class. Contents: . | Installing NodeJS | Installing Visual Studio Code | Hello, World in TypeScript | . If you run into any difficulties following any of these steps, please post (in a non-private question) on CampusWire. ",
    "url": "/~mjk76/teaching/cs490-sp23/tutorials/week1-getting-started.html",
    "relUrl": "/tutorials/week1-getting-started.html"
  }
}
